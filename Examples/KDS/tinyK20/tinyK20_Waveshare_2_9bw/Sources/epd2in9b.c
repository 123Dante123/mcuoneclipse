/**
 *  @filename   :   epd2in9b.c
 *  @brief      :   Implements for Dual-color e-paper library
 *  @author     :   Yehui from Waveshare
 *
 *  Copyright (C) Waveshare     July 13 2017
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documnetation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to  whom the Software is
 * furished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS OR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "Display_Config.h"
#if DISPLAY_IS_3_COLOR

#include <stdlib.h>
#include <stdbool.h>
#include "epd2in9b.h"
#include "epdif.h"

#define USE_OWN_LUT   (0) /* if using own look-up table */

#if 0 /* from https://github.com/drewler/arduino-SSD1675A/blob/master/eink/eink.ino */
const unsigned char init_data_lut[] = { /* LUT 70 bytes, for SSD1675A? */
  0x22,
  0x11, 0x10, 0x00, 0x10, 0x00, 0x00,
  0x11, 0x88, 0x80, 0x80, 0x80, 0x00,
  0x00, 0x6A, 0x9B, 0x9B, 0x9B, 0x9B, 0x00, 0x00, 0x6A, 0x9B, 0x9B, 0x9B, 0x9B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x04, 0x18, 0x04, 0x16, 0x01, 0x0A, 0x0A, 0x0A, 0x0A, 0x02, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x08, 0x3C, 0x07, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#endif

#if 0
/* from GoodDisplay GDEW029Z10 code */
const unsigned char LUTDefault_part[31] = {
  0x32, // command

/*  0x00,0x00,0x00,0x18,
  0x18,0x18,0x18,0x00,
  0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,
  0x40,0x14,0x34,0x01,
  0x00,0x00,0x00,0x00,
  0x00,0x00,
*/
 0x10 //C221 25C partial update waveform
,0x18,0x18,0x08,0x18,0x18
,0x08,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x13
,0x14,0x44,0x12,0x00,0x00
,0x00,0x00,0x00,0x00  };

const unsigned char LUTDefault_full[31] = {
  0x32, // command
/*  0x11,0x11,0x10,0x02,  // full
  0x02,0x22,0x22,0x22,
  0x22,0x22,0x51,0x51,
  0x55,0x88,0x08,0x08,
      0x88,0x88,0x00,0x00,
  0x34,0x23,0x12,0x21,
  0x24,0x28,0x22,0x21,
  0xA1,0x01
*/
 0x02 //C221 25C Full update waveform
,0x02,0x01,0x11,0x12,0x12
,0x22,0x22,0x66,0x69,0x69
,0x59,0x58,0x99,0x99,0x88
,0x00,0x00,0x00,0x00,0xF8
,0xB4,0x13,0x51,0x35,0x51
,0x51,0x19,0x01,0x00  };
#endif

#if USE_OWN_LUT

#if 0 /* BW LUT???? */

const unsigned char lut_vcom0[] =
{
  0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x17, 0x17, 0x00, 0x00, 0x02,
  0x00, 0x0A, 0x01, 0x00, 0x00, 0x01,
  0x00, 0x0E, 0x0E, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_vcom0_quick[] =
{
  0x00, 0x0E, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_ww[] ={
  0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
  0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
  0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
  0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_ww_quick[] ={
  0xA0, 0x0E, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_bw[] ={
  0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
  0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
  0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
  0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_bw_quick[] ={
  0xA0, 0x0E, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_bb[] ={
  0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
  0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
  0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
  0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_bb_quick[] ={
  0x50, 0x0E, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_wb[] ={
  0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
  0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
  0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
  0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_wb_quick[] ={
  0x50, 0x0E, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
#else

/* from GDEW027C44 code */
const unsigned char lut_vcom0[] =
{
0x00  ,0x00,
0x00  ,0x1A ,0x1A ,0x00 ,0x00 ,0x01,
0x00  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0x00  ,0x0E ,0x01 ,0x0E ,0x01 ,0x10,
0x00  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0x00  ,0x04 ,0x10 ,0x00 ,0x00 ,0x05,
0x00  ,0x03 ,0x0E ,0x00 ,0x00 ,0x0A,
0x00  ,0x23 ,0x00 ,0x00 ,0x00 ,0x01
};

//R21H
const unsigned char lut_ww[] ={
0x90  ,0x1A ,0x1A ,0x00 ,0x00 ,0x01,
0x40  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0x84  ,0x0E ,0x01 ,0x0E ,0x01 ,0x10,
0x80  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0x00  ,0x04 ,0x10 ,0x00 ,0x00 ,0x05,
0x00  ,0x03 ,0x0E ,0x00 ,0x00 ,0x0A,
0x00  ,0x23 ,0x00 ,0x00 ,0x00 ,0x01
          };
//R22H  r
const unsigned char lut_bw[] ={
0xA0  ,0x1A ,0x1A ,0x00 ,0x00 ,0x01,
0x00  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0x84  ,0x0E ,0x01 ,0x0E ,0x01 ,0x10,
0x90  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0xB0  ,0x04 ,0x10 ,0x00 ,0x00 ,0x05,
0xB0  ,0x03 ,0x0E ,0x00 ,0x00 ,0x0A,
0xC0  ,0x23 ,0x00 ,0x00 ,0x00 ,0x01
          };
//R23H  w
const unsigned char lut_bb[] ={
0x90  ,0x1A ,0x1A ,0x00 ,0x00 ,0x01,
0x40  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0x84  ,0x0E ,0x01 ,0x0E ,0x01 ,0x10,
0x80  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0x00  ,0x04 ,0x10 ,0x00 ,0x00 ,0x05,
0x00  ,0x03 ,0x0E ,0x00 ,0x00 ,0x0A,
0x00  ,0x23 ,0x00 ,0x00 ,0x00 ,0x01
          };
//R24H  b
const unsigned char lut_wb[] ={
0x90  ,0x1A ,0x1A ,0x00 ,0x00 ,0x01,
0x20  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0x84  ,0x0E ,0x01 ,0x0E ,0x01 ,0x10,
0x10  ,0x0A ,0x0A ,0x00 ,0x00 ,0x08,
0x00  ,0x04 ,0x10 ,0x00 ,0x00 ,0x05,
0x00  ,0x03 ,0x0E ,0x00 ,0x00 ,0x0A,
0x00  ,0x23 ,0x00 ,0x00 ,0x00 ,0x01
          };


#endif

static void SetLut(EPD* epd) {
    unsigned int count;

    EPD_SendCommand(epd, LUT_FOR_VCOM);                            //vcom
    for(count = 0; count < 44; count++) {
      EPD_SendData(epd, lut_vcom0[count]);
    }

    EPD_SendCommand(epd, LUT_WHITE_TO_WHITE);                      //ww --
    for(count = 0; count < 42; count++) {
      EPD_SendData(epd, lut_ww[count]);
    }

    EPD_SendCommand(epd, LUT_BLACK_TO_WHITE);                      //bw r
    for(count = 0; count < 42; count++) {
      EPD_SendData(epd, lut_bw[count]);
    }

    EPD_SendCommand(epd, LUT_WHITE_TO_BLACK);                      //wb w
    for(count = 0; count < 42; count++) {
      EPD_SendData(epd, lut_wb[count]);
    }

    EPD_SendCommand(epd, LUT_BLACK_TO_BLACK);                      //bb b
    for(count = 0; count < 42; count++) {
      EPD_SendData(epd, lut_bb[count]);
    }
}

#if 0
static void SetLutQuick(EPD* epd) {
    unsigned int count;

    EPD_SendCommand(epd, LUT_FOR_VCOM);                            //vcom
    for(count = 0; count < 44; count++) {
      EPD_SendData(epd, lut_vcom0_quick[count]);
    }

    EPD_SendCommand(epd, LUT_WHITE_TO_WHITE);                      //ww --
    for(count = 0; count < 42; count++) {
      EPD_SendData(epd, lut_ww_quick[count]);
    }

    EPD_SendCommand(epd, LUT_BLACK_TO_WHITE);                      //bw r
    for(count = 0; count < 42; count++) {
      EPD_SendData(epd, lut_bw_quick[count]);
    }

    EPD_SendCommand(epd, LUT_WHITE_TO_BLACK);                      //wb w
    for(count = 0; count < 42; count++) {
      EPD_SendData(epd, lut_wb_quick[count]);
    }

    EPD_SendCommand(epd, LUT_BLACK_TO_BLACK);                      //bb b
    for(count = 0; count < 42; count++) {
      EPD_SendData(epd, lut_bb_quick[count]);
    }
}
#endif

static void EPD_SetLut(EPD* epd, const unsigned char* lut, bool quick) {
  epd->lut = lut;
  if (quick) {
   // SetLutQuick(epd);
  } else {
    SetLut(epd);
  }
}
#endif

int EPD_Init(EPD *epd, const unsigned char *lut) {
  epd->reset_pin = RST_PIN;
  epd->dc_pin = DC_PIN;
  epd->cs_pin = CS_PIN;
  epd->busy_pin = BUSY_PIN;
  epd->width = EPD_WIDTH;
  epd->height = EPD_HEIGHT;
  epd->lut = lut;
  
  /* this calls the peripheral hardware interface, see epdif */
  if (EpdInitCallback() != 0) {
    return -1;
  }
  
  /* EPD hardware init start */
  EPD_Reset(epd);
  EPD_SendCommand(epd, BOOSTER_SOFT_START);
  EPD_SendData(epd, 0x17);
  EPD_SendData(epd, 0x17);
  EPD_SendData(epd, 0x17);
  EPD_SendCommand(epd, POWER_ON);
  EPD_WaitUntilIdle(epd);
  EPD_SendCommand(epd, PANEL_SETTING);
  /* RES   : 10       : 128x296
   * REG_EN:   0      : 0: LUT from OTP (default)
   * BWR   :    0     : Pixel with BWR (default)
   * UD    :     1    : Scan up (default)
   * SHL   :      1   : shift right (default)
   * SHD_N :       1  : Booster switch, 1: booster on
   * RST_N :        1 : Soft reset: 1: no effect (default)
   */
  EPD_SendData(epd, 0x8F
#if USE_OWN_LUT
      |(1<<5)
#endif
      );
  EPD_SendCommand(epd, VCOM_AND_DATA_INTERVAL_SETTING);
  EPD_SendData(epd, 0x77);
  EPD_SendCommand(epd, TCON_RESOLUTION);
  EPD_SendData(epd, 0x80);
  EPD_SendData(epd, 0x01);
  EPD_SendData(epd, 0x28);
  EPD_SendCommand(epd, VCM_DC_SETTING_REGISTER);
  EPD_SendData(epd, 0X0A);
#if USE_OWN_LUT
  EPD_SetLut(epd, epd->lut, false);
#endif
  /* EPD hardware init end */
  return 0;
}

/**
 *  @brief: this calls the corresponding function from epdif.h
 *          usually there is no need to change this function
 */
void EPD_DigitalWrite(EPD* epd, int pin, int value) {
  EpdDigitalWriteCallback(pin, value);
}

/**
 *  @brief: this calls the corresponding function from epdif.h
 *          usually there is no need to change this function
 */
int EPD_DigitalRead(EPD* epd, int pin) {
  return EpdDigitalReadCallback(pin);
}

/**
 *  @brief: this calls the corresponding function from epdif.h
 *          usually there is no need to change this function
 */
void EPD_DelayMs(EPD* epd, unsigned int delaytime) {  // 1ms
  EpdDelayMsCallback(delaytime);
}

/**
 *  @brief: basic function for sending commands
 */
void EPD_SendCommand(EPD* epd, unsigned char command) {
  EPD_DigitalWrite(epd, epd->dc_pin, LOW);
  EpdSpiTransferCallback(command);
}

/**
 *  @brief: basic function for sending data
 */
void EPD_SendData(EPD* epd, unsigned char data) {
  EPD_DigitalWrite(epd, epd->dc_pin, HIGH);
  EpdSpiTransferCallback(data);
}

/**
 *  @brief: Wait until the busy_pin goes HIGH
 */
void EPD_WaitUntilIdle(EPD* epd) {
  while(EPD_DigitalRead(epd, epd->busy_pin) == 0) {      //0: busy, 1: idle
    EPD_DelayMs(epd, 100);
  }      
}

/**
 *  @brief: module reset.
 *          often used to awaken the module in deep sleep,
 *          see EPD::Sleep();
 */
void EPD_Reset(EPD* epd) {
  EPD_DigitalWrite(epd, epd->reset_pin, LOW);                //module reset    
  EPD_DelayMs(epd, 200);
  EPD_DigitalWrite(epd, epd->reset_pin, HIGH);
  EPD_DelayMs(epd, 200);    
}

void EPD_DisplayFrame(EPD* epd, const unsigned char* frame_buffer_black, const unsigned char* frame_buffer_red) {
  if (frame_buffer_black != NULL) {
    EPD_SendCommand(epd, DATA_START_TRANSMISSION_1);
    EPD_DelayMs(epd, 2);
    for (int i = 0; i < epd->width * epd->height / 8; i++) {
      EPD_SendData(epd, frame_buffer_black[i]);
     // EPD_SendData(epd, 0xff); /* bit set: white */
    }
    EPD_DelayMs(epd, 2);
  }
  if (frame_buffer_red != NULL) {
    EPD_SendCommand(epd, DATA_START_TRANSMISSION_2);
    EPD_DelayMs(epd, 2);
    for (int i = 0; i < epd->width * epd->height / 8; i++) {
      EPD_SendData(epd, frame_buffer_red[i]);
    }
    EPD_DelayMs(epd, 2);
  }
#if USE_OWN_LUT
  EPD_SetLut(epd, NULL, true);
#endif
  EPD_SendCommand(epd, DISPLAY_REFRESH);
  EPD_WaitUntilIdle(epd);
}

/* After this command is transmitted, the chip would enter the deep-sleep mode to save power. 
   The deep sleep mode would return to standby by hardware reset. The only one parameter is a 
   check code, the command would be executed if check code = 0xA5. 
   You can use EPD_Reset() to awaken and EPD_Init() to initialize */
void EPD_Sleep(EPD* epd) {
  EPD_SendCommand(epd, VCM_DC_SETTING_REGISTER);         //to solve Vcom drop
  EPD_SendData(epd, 0x00);
  EPD_SendCommand(epd, POWER_SETTING);         //power setting
  EPD_SendData(epd, 0x02);        //gate switch to external
  EPD_SendData(epd, 0x00);
  EPD_SendData(epd, 0x00);
  EPD_SendData(epd, 0x00);
  EPD_WaitUntilIdle(epd);
  EPD_SendCommand(epd, POWER_OFF);         //power off
}
#endif /* DISPLAY_IS_3_COLOR */
/* END OF FILE */


