/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : OW1.c
**     CDE edition : Community
**     Project     : FRDM-KL27Z_McuOnEclipseLib
**     Processor   : MKL25Z128VLK4
**     Component   : OneWire
**     Version     : Component 01.130, Driver 01.00, CPU db: 3.00.000
**     Repository  : Legacy User Components
**     Compiler    : GNU C Compiler
**     Date/Time   : 2017-05-26, 12:45, # CodeGen: 205
**     Abstract    :
**
This is a component implementing the 1-Wire protocol.
**     Settings    :
**          Component Name                                 : OW1
**          Data Pin I/O                                   : SDK_BitIO
**          Write Pin                                      : Disabled
**          Timer (LDD)                                    : Disabled
**          Timer (SDK)                                    : Enabled
**            Timer                                        : SDK_Timer
**          Timing                                         : 
**            A: Write 1 Low time (us)                     : 5
**            B: Write 1 High time (us)                    : 64
**            C: Write 0 Low time (us)                     : 60
**            D: Write 0 High time (us)                    : 10
**            E: Delay time before read (us)               : 1
**            F: After read delay time                     : 55
**            H: Reset time (us)                           : 480
**            I: Device response time (us)                 : 70
**            Total slot time (us)                         : 100
**          Buffers                                        : 
**            Output                                       : RBOutput
**            Input                                        : RBInput
**            Time                                         : RBTime
**            Program                                      : RBProgram
**          Debug                                          : Enabled
**            Debug Read Pin                               : SDK_BitIO
**          CriticalSection                                : CS1
**          Utility                                        : UTIL1
**          Wait                                           : WAIT1
**          SDK                                            : MCUC1
**          RTOS                                           : Enabled
**            RTOS                                         : FRTOS1
**          Shell                                          : Enabled
**            Shell                                        : CLS1
**     Contents    :
**         add_CRC       - void OW1_add_CRC(uint8_t bitValue);
**         i_run         - void OW1_i_run(void);
**         i_action      - void OW1_i_action(void);
**         i_reset       - void OW1_i_reset(void);
**         i_presence    - void OW1_i_presence(void);
**         i_send_low    - void OW1_i_send_low(void);
**         i_send_float  - void OW1_i_send_float(void);
**         i_recv_float  - void OW1_i_recv_float(void);
**         i_recv_get    - void OW1_i_recv_get(void);
**         i_recv_low    - void OW1_i_recv_low(void);
**         i_wait        - void OW1_i_wait(void);
**         CalcCRC       - uint8_t OW1_CalcCRC(uint8_t *data, uint8_t dataSize);
**         SendByte      - uint8_t OW1_SendByte(uint8_t data);
**         Receive       - uint8_t OW1_Receive(uint8_t counter);
**         SendReset     - uint8_t OW1_SendReset(void);
**         Count         - uint8_t OW1_Count(void);
**         Waitms        - uint8_t OW1_Waitms(uint8_t key, uint8_t time_ms);
**         ProgramEvent  - uint8_t OW1_ProgramEvent(uint8_t key);
**         SendBytes     - uint8_t OW1_SendBytes(uint8_t *data, uint8_t count);
**         GetBytes      - uint8_t OW1_GetBytes(uint8_t *data, uint8_t count);
**         GetByte       - uint8_t OW1_GetByte(uint8_t *data);
**         GetError      - void OW1_GetError(void);
**         isBusy        - bool OW1_isBusy(void);
**         strcatRomCode - uint8_t OW1_strcatRomCode(uint8_t *buf, size_t bufSize, uint8_t *romCode);
**         ReadRomCode   - uint8_t OW1_ReadRomCode(uint8_t *romCodeBuffer);
**         ResetSearch   - void OW1_ResetSearch(void);
**         TargetSearch  - void OW1_TargetSearch(uint8_t familyCode);
**         Search        - bool OW1_Search(uint8_t *newAddr, bool search_mode);
**         ParseCommand  - uint8_t OW1_ParseCommand(const unsigned char* cmd, bool *handled, const...
**         Deinit        - void OW1%.Init(void) OW1_Deinit(void);
**         Init          - void OW1%.Init(void) OW1_Init(void);
**
**     * Copyright (c) Original implementation: Omar Isaí Pinales Ayala, 2014, all rights reserved.
**      * Updated and maintained by Erich Styger, 2014-2017
**      * Web:         https://mcuoneclipse.com
**      * SourceForge: https://sourceforge.net/projects/mcuoneclipse
**      * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx
**      * All rights reserved.
**      *
**      * Redistribution and use in source and binary forms, with or without modification,
**      * are permitted provided that the following conditions are met:
**      *
**      * - Redistributions of source code must retain the above copyright notice, this list
**      *   of conditions and the following disclaimer.
**      *
**      * - Redistributions in binary form must reproduce the above copyright notice, this
**      *   list of conditions and the following disclaimer in the documentation and/or
**      *   other materials provided with the distribution.
**      *
**      * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**      * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**      * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**      * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**      * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**      * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**      * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**      * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**      * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** ###################################################################*/
/*!
** @file OW1.c
** @version 01.00
** @brief
**
This is a component implementing the 1-Wire protocol.
*/         
/*!
**  @addtogroup OW1_module OW1 module documentation
**  @{
*/         

/* MODULE OW1. */

#include "OW1.h"
#include "DQ1.h" /* data pin */
#include "InputRB1.h" /* input ring buffer */
#include "OutputRB1.h" /* output ring buffer */
#include "TimeRB1.h" /* time ring buffer */
#include "ProgramRB1.h" /* program ring buffer */
#include "Timer1.h" /* Timer Unit */
#include "UTIL1.h" /* Utility */
#include "WAIT1.h" /* Waiting */

// global search state
static unsigned char ROM_NO[8];
static uint8_t LastDiscrepancy;
static uint8_t LastFamilyDiscrepancy;
static uint8_t LastDeviceFlag;

/* Rom commands */
#define RC_READ_ROM          0x33
#define RC_MATCH_ROM         0x55
#define RC_SKIP_ROM          0xCC
#define RC_SEARCH_COND       0xEC
#define RC_SEARCH            0xF0
#define RC_RELEASE           0xFF

#define INPUT          0U
#define OUTPUT         1U

#if OW1_CONFIG_WRITE_PIN /* extra pin only for write bit */
  #define DQ_Init               DQ1_Init(); OW1_CONFIG_WRITE_PIN_INIT
#else
  #define DQ_Init               DQ1_Init()
#endif
#define DQ_Floating             DQ1_SetInput()
#if OW1_CONFIG_WRITE_PIN
  #define DQ_SetLow             OW1_CONFIG_WRITE_PIN_LOW
  #define DQ_Low                OW1_CONFIG_WRITE_PIN_SET_OUTPUT
#else
  #define DQ_SetLow             DQ1_ClrVal()
  #define DQ_Low                DQ1_SetOutput()
#endif
#if OW1_CONFIG_DEBUG_READ_PIN_ENABLED
  #define DBG_Init              OW1_CONFIG_DEBUG_READ_PIN_INIT
  #define DQ_Read               (OW1_CONFIG_DEBUG_READ_PIN_TOGGLE, DQ1_GetVal()!=0)
#else
  #define DBG_Init              /* empty */
  #define DQ_Read               (DQ1_GetVal()!=0)
#endif

/* timer macros */
  #define TU_Init              Timer1_Init()
  #define TU_Deinit            Timer1_Deinit()
  #define TU_GetTimerFrequency Timer1_GetInputFrequency()
  #define TU_Disable           Timer1_Disable()
  #define TU_ResetCounter      Timer1_ResetCounter()
  #define TU_SetPeriodUS(us)   Timer1_SetPeriodTicks((us)*Data.Ticks)
  #define TU_Enable            Timer1_Enable()

typedef enum {
  I_RESET, /* reset instruction */
  I_SEND,  /* send data instruction */
  I_RECV,  /* receive data instruction */
  I_WAIT,  /* wait instruction */
  I_EVENT  /* event instruction */
} INSTR;

typedef enum {
  TS_NOTHING, /* end of timer step */
  /* I_RESET: reset sequence */
  TS_RESET_LOW, /* start of reset, pulling pin LOW */
  TS_RESET_FLOAT, /* reset sequence, release pin */
  TS_PRESENCE, /* check for presence */
  /* I_SEND: writing sequence */
  TS_WRITE_LOW, /* strt of write, pulling pin LOW */
  TS_WRITE_FLOAT, /* writing sequence, releasing pin */
  /* I_RECV: reading sequence */
  TS_READ_LOW, /* start of read, pulling pin low */
  TS_READ_FLOAT, /* middle of read, releasing pin */
  TS_READ_GET, /* reading data */
  /* I_WAIT_ waiting sequence */
  TS_WAIT_INTER,
  TS_WAIT,
  TS_EVENT
} OW1_TimerStep;

typedef struct {
  INSTR Instr     :3; /* instruction code */
  unsigned Count  :5; /* e.g. how many bytes to send */
} PROG;

struct {
#if !MCUC1_CONFIG_NXP_SDK_USED
  LDD_TDeviceData *TUDeviceDataPtr; /* timer handle */
#endif
  OW1_TimerStep Step;
  uint16 Ticks; /* number of timer ticks for one us */
  uint16 WaitTime;
  uint32 WaitTotal;
  uint16 WaitDiv;
  uint16 WaitRes;
  uint8 CRC;
  OW1_Error Error;
  PROG Prog;
  uint8 WorkByte;
  unsigned ToWork     :6;
  unsigned WorkBit    :1;
  volatile unsigned Busy       :1;
  unsigned WorkBitPos :3;
  unsigned WaitEvent  :1;
  unsigned SkipWEvent :1;
  unsigned WaitKey    :5;
} Data;

static void TU_SetTime(uint32_t us) {
  TU_Disable;
  TU_ResetCounter;
  TU_SetPeriodUS(us);
  TU_Enable;
}

static uint8_t read_bit(void) {
  uint8_t bit;
  CS1_CriticalVariable()

  CS1_EnterCritical();
  DQ_Low;
#if OW1_CONFIG_A_READ_TIME>2
  WAIT1_Waitus(OW1_CONFIG_A_READ_TIME-2);
#endif
  DQ_Floating;
#if OW1_CONFIG_E_BEFORE_READ_DELAY_TIME>2
  WAIT1_Waitus(OW1_CONFIG_E_BEFORE_READ_DELAY_TIME-2);
#endif
  bit = DQ_Read;
  CS1_ExitCritical();
#if OW1_CONFIG_F_AFTER_READ_DELAY_TIME>2
  WAIT1_Waitus(OW1_CONFIG_F_AFTER_READ_DELAY_TIME-2);
#endif
  return bit;
}

static void write_bit(uint8_t bit) {
  CS1_CriticalVariable()

  if (bit&1) {
    CS1_EnterCritical();
    DQ_Low;
    WAIT1_Waitus(OW1_CONFIG_A_WRITE_1_LOW_TIME);
    DQ_Floating;
    WAIT1_Waitus(OW1_CONFIG_B_WRITE_1_HIGH_TIME);
    CS1_ExitCritical();
  } else { /* zero bit */
    CS1_EnterCritical();
    DQ_Low;
    WAIT1_Waitus(OW1_CONFIG_C_WRITE_0_LOW_TIME);
    DQ_Floating;
    WAIT1_Waitus(OW1_CONFIG_D_WRITE_0_HIGH_TIME);
    CS1_ExitCritical();
  }
}

static void OW1_OnTimerRestart(void) {
  switch(Data.Step) {
    case TS_NOTHING:
      if(ProgramRB1_NofElements()==0) {
        TU_Disable;
        Data.Busy = FALSE;
      } else {
        OW1_i_action();
      }
      break;
    case TS_RESET_LOW:
      OW1_i_reset();
      break;
    case TS_RESET_FLOAT:
      DQ_Floating;
      TU_SetTime(OW1_CONFIG_I_RESPONSE_TIME); /* have it floating for this time until handling of TS_PRESENCE */
      Data.Step = TS_PRESENCE;
      break;
    case TS_PRESENCE:
      OW1_i_presence();
      break;
    case TS_WRITE_LOW:
      OW1_i_send_low();
      break;
    case TS_WRITE_FLOAT:
      OW1_i_send_float();
      break;
    case TS_READ_LOW:
      OW1_i_recv_low();
      break;
    case TS_READ_FLOAT:
      OW1_i_recv_float();
      break;
    case TS_READ_GET:
      OW1_i_recv_get();
      break;
    case TS_WAIT_INTER:
      Data.WaitDiv--;
      if(Data.WaitDiv == 0) {
        TU_SetPeriodUS(Data.WaitRes);
        Data.Step = TS_WAIT;
      }
      break;
    case TS_WAIT:
      Data.WaitKey = Data.Prog.Count;
      OW1_i_action();
      Data.WaitEvent = TRUE;
      Data.SkipWEvent = TRUE;
      break;
    case TS_EVENT:
      OW1_i_action();
      break;
    default:
      break;
  } /* switch */
  if(Data.SkipWEvent) {
    Data.SkipWEvent = FALSE;
  } else {
    if(Data.WaitEvent) {
      Data.WaitEvent = FALSE;
    }
  }
}

#if OW1_CONFIG_PARSE_COMMAND_ENABLED
static uint8_t PrintStatus(const CLS1_StdIOType *io) {
  CLS1_SendStatusStr((unsigned char*)"OW1", (unsigned char*)"\r\n", io->stdOut);
#if OW1_CONFIG_DEBUG_READ_PIN_ENABLED
  CLS1_SendStatusStr((unsigned char*)"  debug pin", (unsigned char*)"yes\r\n", io->stdOut);
#else
  CLS1_SendStatusStr((unsigned char*)"  debug pin", (unsigned char*)"no\r\n", io->stdOut);
#endif
  return ERR_OK;
}

static uint8_t PrintHelp(const CLS1_StdIOType *io) {
  CLS1_SendHelpStr((unsigned char*)"OW1", (unsigned char*)"Group of OW1 commands\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  reset", (unsigned char*)"Send a RESET sequence to the bus\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  read rom", (unsigned char*)"Send a READ ROM (0x33) to the bus\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  search", (unsigned char*)"Search for devices on the bus\r\n", io->stdOut);
  return ERR_OK;
}
#endif /* OW1_CONFIG_PARSE_COMMAND_ENABLED */

/*
** ===================================================================
**     Method      :  OW1_GetError (component OneWire)
**     Description :
**         Returns the error
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
OW1_Error OW1_GetError(void)
{
  return Data.Error;
}

/*
** ===================================================================
**     Method      :  OW1_SendBytes (component OneWire)
**     Description :
**         Sends multiple bytes
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Array of bytes to add to output stream.
**         count           - Number of bytes to add to output
**                           stream. (Valid range 0 - 31)
**     Returns     :
**         ---             - error code
** ===================================================================
*/
uint8_t OW1_SendBytes(uint8_t *data, uint8_t count)
{
  PROG pr, last;

  (void)ProgramRB1_Peek(0, (uint8_t*)&last);
  if((last.Instr != I_SEND && ProgramRB1_NofFreeElements()==0) || (OutputRB1_NofFreeElements() < count)) {
    return ERR_FAILED;
  }
  pr.Instr = I_SEND;
  pr.Count = count;
  for(;count>0;count--) {
    (void)OutputRB1_Put(*data);
    data++;
  }
  if(last.Instr == I_SEND) { /* update last element */
    last.Count += pr.Count; /* update */
    (void)ProgramRB1_Update(0, (uint8_t*)&last); /* update */
  } else {
    (void)ProgramRB1_Put(*(uint8_t*)&pr);
  }
  if(!Data.Busy) {
    OW1_i_action();
    OW1_i_run();
    OW1_i_send_low();
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  OW1_i_run (component OneWire)
**     Description :
**         Instruction run
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_run(void)
{
  Data.Busy = TRUE;
  TU_ResetCounter;
  TU_Enable;
}

/*
** ===================================================================
**     Method      :  OW1_i_action (component OneWire)
**     Description :
**         action instruction
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_action(void)
{
  if(ProgramRB1_NofElements()==0) {
    TU_SetTime(OW1_CONFIG_SLOT_TIME);
    Data.Step = TS_NOTHING;
    return;
  }
  (void)ProgramRB1_Get((uint8_t*)&Data.Prog);
  switch(Data.Prog.Instr) {
    case I_RESET:
      TU_SetTime(OW1_CONFIG_H_RESET_TIME);
      Data.Step = TS_RESET_LOW;
      break;
    case I_SEND:
      Data.ToWork = Data.Prog.Count;
      OW1_i_send_float();
      break;
    case I_RECV:
      Data.ToWork = Data.Prog.Count;
      Data.WorkByte = 0;
      TU_SetTime(OW1_CONFIG_A_READ_TIME);
      Data.Step = TS_READ_LOW;
      break;
    case I_WAIT:
      (void)TimeRB1_Get(&Data.WaitTime);
      Data.WaitTotal = (uint32) Data.WaitTime * Data.Ticks * 1000U;
      Data.WaitDiv = Data.WaitTotal >> 16;
      Data.WaitRes = Data.WaitTotal & 0x0000FFFF;
      if(Data.WaitDiv == 0) {
        TU_SetPeriodUS(Data.WaitRes);
        Data.Step = TS_WAIT;
      } else {
        TU_SetPeriodUS(0xFFFF);
        Data.Step = TS_WAIT_INTER;
      }
      break;
    case I_EVENT:
      TU_SetTime(OW1_CONFIG_H_RESET_TIME);
      Data.Step = TS_EVENT;
      break;
    default:
      break;
  } /* switch */
}

/*
** ===================================================================
**     Method      :  OW1_i_presence (component OneWire)
**     Description :
**         presence instruction
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_presence(void)
{
  /* check response */
  if(DQ_Read) { /* level must be pulled down by a device on the bus */
    Data.Step = TS_NOTHING;
    Data.Error = OWERR_NO_DEVICE;
  } else {
    Data.Error = OWERR_OK;
    OW1_i_action();
  }
}

/*
** ===================================================================
**     Method      :  OW1_i_reset (component OneWire)
**     Description :
**         reset instruction
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_reset(void)
{
  DQ_Low;
  TU_SetTime(OW1_CONFIG_H_RESET_TIME);
  Data.Step = TS_RESET_FLOAT;
}

/*
** ===================================================================
**     Method      :  OW1_SendReset (component OneWire)
**     Description :
**         Sends a reset to the bus
**     Parameters  : None
**     Returns     :
**         ---             - error code
** ===================================================================
*/
uint8_t OW1_SendReset(void)
{
  PROG pr;

  if(ProgramRB1_NofFreeElements()==0) {
    return ERR_FAILED;
  }
  pr.Instr = I_RESET;
  (void)ProgramRB1_Put(*(uint8_t*)&pr);
  if(!Data.Busy) { /* start action */
    OW1_i_action();
    OW1_i_reset();
    OW1_i_run();
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  OW1_i_send_low (component OneWire)
**     Description :
**         sending a low signal
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_send_low(void)
{
  DQ_Low;
  if(Data.WorkBit) {
    TU_SetTime(OW1_CONFIG_A_WRITE_1_LOW_TIME);
    Data.SkipWEvent = TRUE;
  } else {
    TU_SetTime(OW1_CONFIG_C_WRITE_0_LOW_TIME);
  }
  Data.Step = TS_WRITE_FLOAT; /* next step is to release pin */
}

/*
** ===================================================================
**     Method      :  OW1_i_send_float (component OneWire)
**     Description :
**         using data pin in input mode
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_send_float(void)
{
  DQ_Floating;
  if(Data.WorkBitPos==0) { /* all bits sent? */
    if(Data.ToWork) {
      (void)OutputRB1_Get(&Data.WorkByte);
      Data.ToWork--;
    } else {
      OW1_i_action();
      return;
    }
  }
  Data.WorkBit = Data.WorkByte & 1;
  Data.WorkByte >>= 1;
  if(Data.WorkBit) { /* set time for when we will get back to floating */
    TU_SetTime(OW1_CONFIG_B_WRITE_1_HIGH_TIME);
  } else {
    TU_SetTime(OW1_CONFIG_D_WRITE_0_HIGH_TIME);
  }
  Data.WorkBitPos++;
  Data.Step = TS_WRITE_LOW; /* next action for the next bit: pull LOW to start new bit */
}

/*
** ===================================================================
**     Method      :  OW1_SendByte (component OneWire)
**     Description :
**         Sends a single byte
**     Parameters  :
**         NAME            - DESCRIPTION
**         data            - Variable to save the byte.
**     Returns     :
**         ---             - error code
** ===================================================================
*/
uint8_t OW1_SendByte(uint8_t data)
{
  PROG pr, last;

  (void)ProgramRB1_Peek(0, (uint8_t*)&last);
  if(last.Instr == I_SEND) {
    (void)OutputRB1_Put(data);
    last.Count++; /* update */
    (void)ProgramRB1_Update(0, (uint8_t*)&last); /* update element */
  } else {
    if(ProgramRB1_NofFreeElements()==0) {
      return ERR_FAILED;
    }
    (void)OutputRB1_Put(data);
    pr.Instr = I_SEND;
    pr.Count = 1;
    (void)ProgramRB1_Put(*(uint8_t*)&pr);
  }
  if(!Data.Busy) {
    OW1_i_action();
    OW1_i_send_low();
    OW1_i_run();
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  OW1_i_recv_get (component OneWire)
**     Description :
**         instruction to get a bit
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_recv_get(void)
{
  Data.WorkByte >>= 1;
  Data.WorkBit = DQ_Read;
  OW1_add_CRC(Data.WorkBit);
  Data.WorkByte += (Data.WorkBit ? 0x80 : 0);
  if(Data.WorkBitPos == 7) { /* Full byte */
    (void)InputRB1_Put(Data.WorkByte);
    Data.ToWork--;
    if(Data.ToWork == 0) {  /* finish */
      if(Data.CRC){
        Data.Error = OWERR_CRC;
      } else {
        Data.Error = OWERR_OK;
        OW1_OnBlockReceived();
      }
      OW1_i_action();
      return;
    }
  }
  Data.WorkBitPos++;
  TU_SetTime(OW1_CONFIG_F_AFTER_READ_DELAY_TIME);
  Data.Step = TS_READ_LOW;
}

/*
** ===================================================================
**     Method      :  OW1_i_recv_float (component OneWire)
**     Description :
**         start receiving a byte in floating mode
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_recv_float(void)
{
  DQ_Floating;
  TU_SetTime(OW1_CONFIG_E_BEFORE_READ_DELAY_TIME);
  Data.SkipWEvent = TRUE;
  Data.Step = TS_READ_GET;
}

/*
** ===================================================================
**     Method      :  OW1_i_recv_low (component OneWire)
**     Description :
**         receive a bit from the low state
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_recv_low(void)
{
  DQ_Low;
  Data.SkipWEvent = TRUE;
  TU_SetTime(OW1_CONFIG_A_READ_TIME);
  Data.Step = TS_READ_FLOAT;
}

/*
** ===================================================================
**     Method      :  OW1_Receive (component OneWire)
**     Description :
**         Programs a read operation after the master send all in
**         output buffer. Don't use a SendReset while the data is
**         coming.
**     Parameters  :
**         NAME            - DESCRIPTION
**         counter         - Number of bytes to receive from
**                           slave
**     Returns     :
**         ---             - error code
** ===================================================================
*/
uint8_t OW1_Receive(uint8_t counter)
{
  PROG pr;

  if(ProgramRB1_NofFreeElements()==0) {
    return ERR_FAILED;
  }
  pr.Instr = I_RECV;
  pr.Count = counter;
  (void)ProgramRB1_Put(*(uint8_t*)&pr);
  if(!Data.Busy) {
    OW1_i_action();
    OW1_i_recv_low();
    OW1_i_run();
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  OW1_ProgramEvent (component OneWire)
**     Description :
**         Used to add a program event
**     Parameters  :
**         NAME            - DESCRIPTION
**         key             - Key to identificate the event, applies
**                           only if OnProgramEvent is enabled. (Valid
**                           range 0 - 31)
**     Returns     :
**         ---             - error code
** ===================================================================
*/
uint8_t OW1_ProgramEvent(uint8_t key)
{
  PROG pr;

  if(ProgramRB1_NofFreeElements()==0) {
    return ERR_FAILED;
  }
  pr.Instr = I_EVENT;
  pr.Count = key;
  (void)ProgramRB1_Put(*(uint8_t*)&pr);
  if(!Data.Busy) {
    OW1_i_action();
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  OW1_i_wait (component OneWire)
**     Description :
**         wait instruction
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_i_wait(void)
{
  Data.WaitEvent = FALSE;
}

/*
** ===================================================================
**     Method      :  OW1_Waitms (component OneWire)
**     Description :
**         Programs a pause between instruccions.
**     Parameters  :
**         NAME            - DESCRIPTION
**         key             - Key to identify the source of the event.
**         time_ms         - Value of time to wait.
**     Returns     :
**         ---             - error code
** ===================================================================
*/
uint8_t OW1_Waitms(uint8_t key, uint8_t time_ms)
{
  PROG pr;
  CS1_CriticalVariable()

  if((ProgramRB1_NofFreeElements()==0) || (TimeRB1_NofFreeElements()==0)) {
    return ERR_FAILED;
  }
  CS1_EnterCritical();
  pr.Instr = I_WAIT;
  pr.Count = key;
  (void)ProgramRB1_Put(*(uint8_t*)&pr);
  (void)TimeRB1_Put(time_ms);
  CS1_ExitCritical();
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  OW1_Count (component OneWire)
**     Description :
**         Returns the number of elements stored on input buffer that
**         are ready to read.
**     Parameters  : None
**     Returns     :
**         ---             - number of elements
** ===================================================================
*/
uint8_t OW1_Count(void)
{
  return InputRB1_NofElements();
}

/*
** ===================================================================
**     Method      :  OW1_add_CRC (component OneWire)
**     Description :
**         Adds a bit to CRC accumulator.
**     Parameters  :
**         NAME            - DESCRIPTION
**         bitValue        - Bit to add to CRC accumulator
**     Returns     : Nothing
** ===================================================================
*/
void OW1_add_CRC(uint8_t bitValue)
{
  bool fb;

  fb = (Data.CRC & 0x01) ^ bitValue;
  Data.CRC >>= 1;
  if(fb) {
    Data.CRC ^= 0x8C;
  }
}

/*
** ===================================================================
**     Method      :  OW1_GetByte (component OneWire)
**     Description :
**         Get a single byte from the bus
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to were to store the data
**     Returns     :
**         ---             - error code
** ===================================================================
*/
uint8_t OW1_GetByte(uint8_t *data)
{
  if (InputRB1_NofElements()==0) {
    return ERR_FAILED;
  }
  (void)InputRB1_Get(data);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  OW1_GetBytes (component OneWire)
**     Description :
**         Gets multiple bytes from the bus
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to where to store the data
**         count           - Number of bytes
**     Returns     :
**         ---             - error code
** ===================================================================
*/
uint8_t OW1_GetBytes(uint8_t *data, uint8_t count)
{
  if(count > InputRB1_NofElements()) {
    return ERR_FAILED;
  }
  for(;count>0;count--) {
    (void)InputRB1_Get(data);
    data++;
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  OW1_isBusy (component OneWire)
**     Description :
**         Returns TRUE if the bus is busy, FALSE otherwise
**     Parameters  : None
**     Returns     :
**         ---             - TRUE if device is busy
** ===================================================================
*/
bool OW1_isBusy(void)
{
  return (Data.Busy!=0);
}

/*
** ===================================================================
**     Method      :  OW1_CalcCRC (component OneWire)
**     Description :
**         Calculates the CRC over a number of bytes
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to data
**         dataSize        - number of data bytes
**     Returns     :
**         ---             - calculated CRC
** ===================================================================
*/
uint8_t OW1_CalcCRC(uint8_t *data, uint8_t dataSize)
{
  uint8_t crc, i, x, y;

  crc = 0;
  for(x=0;x<dataSize;x++){
    y = data[x];
    for(i=0;i<8;i++) { /* go through all bits of the data byte */
      if((crc&0x01)^(y&0x01)) {
        crc >>= 1;
        crc ^= 0x8c;
      } else {
        crc >>= 1;
      }
      y >>= 1;
    }
  }
  return crc;
}

/*
** ===================================================================
**     Method      :  OW1_Init (component OneWire)
**     Description :
**         Initializes this device.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_Init(void)
{
#if MCUC1_CONFIG_NXP_SDK_USED
  /* using SDK, need to initialize inherited components */
  TU_Init; /* timer */
  DQ_Init; /* data pin */
  DBG_Init; /* optional debug pin */
  InputRB1_Init(); /* input ring buffer */
  OutputRB1_Init(); /* output ring buffer */
  ProgramRB1_Init(); /* program ring buffer */
  TimeRB1_Init(); /* time ring buffer */
#else
  Data.TUDeviceDataPtr = TU_Init; /* timer init */
#endif
  Data.Ticks = TU_GetTimerFrequency/1000000U;
  Data.Busy = FALSE;
  Data.WorkBitPos = 0;
  Data.WaitEvent = FALSE;
  Data.SkipWEvent = FALSE;
  Data.Step = TS_NOTHING;
  Data.CRC = 0;
  Data.Error = OWERR_OK;

  DQ_Floating; /* input mode, let the pull-up take the signal high */
  /* load LOW to output register. We won't change that value afterwards, we only switch between output and input/float mode */
  DQ_SetLow;
}

/*
** ===================================================================
**     Method      :  OW1_Deinit (component OneWire)
**     Description :
**         Driver de-initialization
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_Deinit(void)
{
  TU_Deinit; /* timer deinit */
#if !MCUC1_CONFIG_NXP_SDK_USED
  Data.TUDeviceDataPtr = NULL;
#endif
 // DQ_Deinit; /* data pin */
  DQ_Floating; /* input mode, tristate pin */
 // DBG_Deinit; /* optional debug pin */
  InputRB1_Deinit(); /* input ring buffer */
  OutputRB1_Deinit(); /* output ring buffer */
  ProgramRB1_Deinit(); /* program ring buffer */
  TimeRB1_Deinit(); /* time ring buffer */
  Data.Ticks = 0;
  Data.Busy = FALSE;
  Data.WorkBitPos = 0;
  Data.WaitEvent = FALSE;
  Data.SkipWEvent = FALSE;
  Data.Step = TS_NOTHING;
  Data.CRC = 0;
  Data.Error = OWERR_OK;
}


/*
** ===================================================================
**     Method      :  OW1_OnCounterRestart (component OneWire)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void Timer1_OnCounterRestart(void)
{
  OW1_OnTimerRestart();
}

/*
** ===================================================================
**     Method      :  OW1_ParseCommand (component OneWire)
**     Description :
**         Shell Command Line parser. Method is only available if Shell
**         is enabled in the component properties.
**     Parameters  :
**         NAME            - DESCRIPTION
**         cmd             - command string
**       * handled         - Pointer to variable which tells if
**                           the command has been handled or not
**         io              - Pointer to I/O structure
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t OW1_ParseCommand(const unsigned char* cmd, bool *handled, const CLS1_StdIOType *io)
{
#if OW1_CONFIG_PARSE_COMMAND_ENABLED
  uint8_t res = ERR_OK;
  uint8_t buf[32];

  if (UTIL1_strcmp((char*)cmd, CLS1_CMD_HELP) == 0
    || UTIL1_strcmp((char*)cmd, "OW1 help") == 0)
  {
    *handled = TRUE;
    return PrintHelp(io);
  } else if (   (UTIL1_strcmp((char*)cmd, CLS1_CMD_STATUS)==0)
             || (UTIL1_strcmp((char*)cmd, "OW1 status")==0)
            )
  {
    *handled = TRUE;
    res = PrintStatus(io);
  } else if (UTIL1_strcmp((char*)cmd, "OW1 read rom")==0) {
    uint8_t rom[OW1_ROM_CODE_SIZE];

    *handled = TRUE;
    res = OW1_ReadRomCode(&rom[0]);
    if (res!=ERR_OK) {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"ReadRomCode() ERROR (");
      UTIL1_strcatNum8u(buf, sizeof(buf), res);
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)")\r\n");
      CLS1_SendStr(buf, io->stdErr);
    } else {
      buf[0] = '\0';
      (void)OW1_strcatRomCode(buf, sizeof(buf), &rom[0]);
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
      CLS1_SendStr(buf, io->stdOut);
    }
  } else if (UTIL1_strcmp((char*)cmd, "OW1 reset")==0) {
    *handled = TRUE;
    res = OW1_SendReset();
    while(OW1_isBusy()) { /* wait */ }
    if (OW1_GetError()==OWERR_OK) {
      CLS1_SendStr((unsigned char*)"Device present\r\n", io->stdOut);
    } else {
      CLS1_SendStr((unsigned char*)"No device present?\r\n", io->stdErr);
    }
    if (res!=ERR_OK) {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"ERROR (");
      UTIL1_strcatNum8u(buf, sizeof(buf), res);
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)")\r\n");
      CLS1_SendStr(buf, io->stdErr);
    }
  } else if (UTIL1_strcmp((char*)cmd, "OW1 search")==0) {
    uint8_t rom[OW1_ROM_CODE_SIZE];
    bool found;
    int nofFound = 0;

    *handled = TRUE;
    OW1_ResetSearch();
    do {
      found = OW1_Search(&rom[0], TRUE);
      if (found) {
        nofFound++;
        buf[0] = '\0';
        (void)OW1_strcatRomCode(buf, sizeof(buf), &rom[0]);
        UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
        CLS1_SendStr(buf, io->stdOut);
      }
    } while(found);
    if (nofFound==0) {
      CLS1_SendStr((unsigned char*)"No device found!\r\n", io->stdErr);
    }
    return ERR_OK;
  }
  return res;
#else
  (void)cmd;
  (void)handled;
  (void)io;
  return ERR_OK;
#endif
}

/*
** ===================================================================
**     Method      :  OW1_ReadRomCode (component OneWire)
**     Description :
**         Read the ROM code. Only works with one device on the bus.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * romCodeBuffer   - Pointer to a buffer
**                           with 8 bytes where the ROM code gets stored
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t OW1_ReadRomCode(uint8_t *romCodeBuffer)
{
  uint8_t res;

  OW1_SendReset();
  while(OW1_isBusy()) { /* wait */ }
  OW1_SendByte(RC_READ_ROM);
  while(OW1_isBusy()) { /* wait */ }
  OW1_Receive(OW1_ROM_CODE_SIZE); /* 8 bytes for the ROM code */
  while(OW1_isBusy()) { /* wait */ }
  OW1_SendByte(RC_RELEASE);
  while(OW1_isBusy()) { /* wait */ }
  /* copy ROM code */
  res = OW1_GetBytes(romCodeBuffer, OW1_ROM_CODE_SIZE); /* 8 bytes */
  if (res!=ERR_OK) {
    return res; /* error */
  }
  /* index 0  : family code
     index 1-6: 48bit serial number
     index 7  : CRC
  */
  if (OW1_CalcCRC(&romCodeBuffer[0], OW1_ROM_CODE_SIZE-1)!=romCodeBuffer[OW1_ROM_CODE_SIZE-1]) {
    return ERR_CRC; /* wrong CRC? */
  }
  return ERR_OK; /* ok */
}

/*
** ===================================================================
**     Method      :  OW1_strcatRomCode (component OneWire)
**     Description :
**         Appends the ROM code to a string.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to zero terminated buffer
**         bufSize         - size of buffer
**       * romCode         - Pointer to 8 bytes of ROM Code
**     Returns     :
**         ---             - error code
** ===================================================================
*/
uint8_t OW1_strcatRomCode(uint8_t *buf, size_t bufSize, uint8_t *romCode)
{
  int j;

  for(j=0;j<OW1_ROM_CODE_SIZE;j++) {
    UTIL1_strcatNum8Hex(buf, bufSize, romCode[j]);
    if(j<OW1_ROM_CODE_SIZE-1) {
      UTIL1_chcat(buf, bufSize, '-');
    }
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  OW1_ResetSearch (component OneWire)
**     Description :
**         Reset the search state
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void OW1_ResetSearch(void)
{
  /* reset the search state */
  int i;

  LastDiscrepancy = 0;
  LastDeviceFlag = FALSE;
  LastFamilyDiscrepancy = 0;
  for(i = 7; ; i--) {
    ROM_NO[i] = 0;
    if (i==0) {
      break;
    }
  }
}

/*
** ===================================================================
**     Method      :  OW1_TargetSearch (component OneWire)
**     Description :
**         
**     Parameters  :
**         NAME            - DESCRIPTION
**         familyCode      - family code to restrict
**                           search for
**     Returns     : Nothing
** ===================================================================
*/
void OW1_TargetSearch(uint8_t familyCode)
{
  /* set the search state to find SearchFamily type devices */
  int i;

  ROM_NO[0] = familyCode;
  for (i = 1; i < 8; i++) {
    ROM_NO[i] = 0;
  }
  LastDiscrepancy = 64;
  LastFamilyDiscrepancy = 0;
  LastDeviceFlag = FALSE;
}

/*
** ===================================================================
**     Method      :  OW1_Search (component OneWire)
**     Description :
**         
**     Parameters  :
**         NAME            - DESCRIPTION
**       * newAddr         - Pointer to 8 bytes of data where
**                           to store the new address
**         search_mode     - 
**     Returns     :
**         ---             - TRUE if new device has been found, FALSE
**                           otherwise.
** ===================================================================
*/
bool OW1_Search(uint8_t *newAddr, bool search_mode)
{
// Version from https://raw.githubusercontent.com/PaulStoffregen/OneWire/master/OneWire.cpp
//--------------------------------------------------------------------------
// Perform the 1-Wire Search Algorithm on the 1-Wire bus using the existing
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
  uint8_t id_bit_number;
  uint8_t last_zero, rom_byte_number, search_result;
  uint8_t id_bit, cmp_id_bit;
  unsigned char rom_byte_mask, search_direction;
  uint8_t res;

  /* initialize for search */
  id_bit_number = 1;
  last_zero = 0;
  rom_byte_number = 0;
  rom_byte_mask = 1;
  search_result = 0;

  /* if the last call was not the last one */
  if (!LastDeviceFlag) {
    /* 1-Wire reset */
    res = OW1_SendReset();
    while(OW1_isBusy()) { /* wait */ }
    if (res!=ERR_OK || OW1_GetError()!=OWERR_OK) {
      /* reset the search */
      LastDiscrepancy = 0;
      LastDeviceFlag = FALSE;
      LastFamilyDiscrepancy = 0;
      return FALSE;
    }
    /* issue the search command */
    if (search_mode) {
      OW1_SendByte(RC_SEARCH);   /* NORMAL SEARCH */
      while(OW1_isBusy()) { /* wait */ }
    } else {
      OW1_SendByte(RC_SEARCH_COND);   /* CONDITIONAL SEARCH */
      while(OW1_isBusy()) { /* wait */ }
    }
    /* loop to do the search */
    do  {
      /* read a bit and its complement */
      id_bit = read_bit();
      cmp_id_bit = read_bit();

      /* check for no devices on 1-wire */
      if ((id_bit==1) && (cmp_id_bit==1)) {
        break;
      } else {
        /* all devices coupled have 0 or 1 */
        if (id_bit != cmp_id_bit) {
          search_direction = id_bit;  // bit write value for search
        } else {
          /* if this discrepancy if before the Last Discrepancy */
          /* on a previous next then pick the same as last time */
          if (id_bit_number < LastDiscrepancy) {
            search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
          } else {
            /* if equal to last pick 1, if not then pick 0 */
            search_direction = (id_bit_number == LastDiscrepancy);
          }
          /* if 0 was picked then record its position in LastZero */
          if (search_direction == 0) {
            last_zero = id_bit_number;
            /* check for Last discrepancy in family */
            if (last_zero < 9)
               LastFamilyDiscrepancy = last_zero;
            }
          }

          /* set or clear the bit in the ROM byte rom_byte_number */
          /* with mask rom_byte_mask */
          if (search_direction == 1) {
            ROM_NO[rom_byte_number] |= rom_byte_mask;
          } else {
            ROM_NO[rom_byte_number] &= ~rom_byte_mask;
          }
          /* serial number search direction write bit */
          write_bit(search_direction);

          /* increment the byte counter id_bit_number */
          /* and shift the mask rom_byte_mask */
          id_bit_number++;
          rom_byte_mask <<= 1;

          /* if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask */
          if (rom_byte_mask == 0) {
            rom_byte_number++;
            rom_byte_mask = 1;
          }
       }
    }
    while(rom_byte_number < 8);  /* loop until through all ROM bytes 0-7 */
    /* if the search was successful then */
    if (!(id_bit_number < 65)) {
      /* search successful so set LastDiscrepancy,LastDeviceFlag,search_result */
      LastDiscrepancy = last_zero;

      /* check for last device */
      if (LastDiscrepancy == 0) {
        LastDeviceFlag = TRUE;
      }
      search_result = TRUE;
    }
  }
  /* if no device found then reset counters so next 'search' will be like a first */
  if (!search_result || !ROM_NO[0])  {
    LastDiscrepancy = 0;
    LastDeviceFlag = FALSE;
    LastFamilyDiscrepancy = 0;
    search_result = FALSE;
  } else {
    for (int i = 0; i < 8; i++) {
      newAddr[i] = ROM_NO[i];
    }
  }
  return search_result;
}

/* END OW1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.5 [05.21]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
