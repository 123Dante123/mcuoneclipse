/*!
\page page_Queue Lab: Queues and Malloc
\author Erich Styger, erich.styger@hslu.ch

\section s_requirement Requirements
We do have two task right now: the main task and the shell task.
And both are writing to the shell. We need to make sure that we do not access concurrently the SCI.
One way to do this is to use message passing between the main task and the shell.
So we implement a message queue which is used to transfer messages from the main task to the shell task.

\section s_hints Hints
- It is a good idea to create MyQueue.c and MyQueue.h. Queue.h is already used by FreeRTOS.
- Following interface might be used
\verbatim
/*!
 * \brief Sends a string to the queue. Note that if the queue is full, it will block.
 * \param msg Pointer to the string.
 */
void QUEUE_SendMessage(const char_t *msg);

/*!
 * \brief Receives an item from the queue, and returns immediately if the queue is empty.
 * \return Pointer to the message, or NULL. The caller has to free the memory!
 */
const char_t *QUEUE_ReceiveMessage(void);

/*! \brief Initializes the queue */
void QUEUE_Init(void);
\endverbatim
- At creation of the queue, you need to specify the number of items, and the size of each item.
  One way would be to specify a maximum message size, but this would be a limitation of your design.
  Another way would be to use a queue of pointers (to the messages). But here you need to consider
  that you need to allocate memory on the heap for each message (copy the message), and that the
  caller of QUEUE_ReceiveMessage() needs to deallocate the memory.
- Have fun :-)  

\section s_journal Questions
- Discuss the pros and cons of dynamic memory allocation in this lab.
- Discuss the different memory allocation schemes FreeRTOS offers.
*/
