/*!
\page page_Semaphore Lab: Semaphore
\author Erich Styger, erich.styger@hslu.ch

\section s_requirement Requirements
Using the FreeRTOS (www.freertos.org) we are using binary semaphores for Inter-Process Communication (IPC).
For this we create a 'master' and a 'slave' task. The master is sending a signal (using a binary semaphore)
to the 'slave'. To visualize the IPC, the slave process is going to flash an LED.

\section s_hints Hints
- Implement Sem.c. SEM_Init() should create two tasks which communicate with semaphores.
- Extend your application with a master and a slave task.
- Keep in mind that in FreeRTOS semaphores are implemented as queues (the semaphore macros
  are using the Queue API). As such, a binary semaphore is a queue with one element.
  Posting (giving a semaphore) is setting the number of elements in the queue to 1,
  while taking the semaphore is consuming that element. As such, one task is giving the
  semaphore only, and the slave task is taking the semaphore.
- Think about a good place to create the semaphore.
- You should take appropriate steps to verify that your semaphore is valid before using it.
- Have fun :-)  

\section s_journal Questions
- xSemaphoreTake() is using a second argument. Describe for which use cases this second argument is useful?
*/
