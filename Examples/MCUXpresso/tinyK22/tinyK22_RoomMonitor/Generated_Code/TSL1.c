/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : TSL1.h
**     Project     : tinyK22_SGP30
**     Processor   : MK22FN512VLH12
**     Component   : TSL2561
**     Version     : Component 01.002, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2018-10-01, 18:28, # CodeGen: 9
**     Abstract    :
**
**     Settings    :
**
**     Contents    :
**         Disable                - uint8_t TSL1_Disable(void);
**         Enable                 - uint8_t TSL1_Enable(void);
**         SetIntegrationTime     - uint8_t TSL1_SetIntegrationTime(uint8_t timing);
**         SetGain                - uint8_t TSL1_SetGain(uint8_t gain);
**         ReadRawDataFull        - uint8_t TSL1_ReadRawDataFull(uint16_t *data);
**         ReadRawDataInfrared    - uint8_t TSL1_ReadRawDataInfrared(uint16_t *data);
**         ReadData               - uint8_t TSL1_ReadData(uint16_t *broadband, uint16_t *ir);
**         CalculateLux           - uint32_t TSL1_CalculateLux(uint16_t broadband, uint16_t ir);
**         GetLux                 - uint8_t TSL1_GetLux(uint32_t *lux);
**         GetLuminosity          - void TSL1_GetLuminosity(uint16_t *broadband, uint16_t *ir);
**         LuxToAmbientPercentage - void TSL1_LuxToAmbientPercentage(uint32_t luxVal, uint8_t *ambient);
**         ParseCommand           - uint8_t TSL1_ParseCommand(const unsigned char* cmd, bool *handled, const...
**         Deinit                 - void TSL1_Deinit(void);
**         Init                   - void TSL1_Init(void);
**
** * Copyright (c) 2017, Erich Styger
**  * Web:         https://mcuoneclipse.com
**  * SourceForge: https://sourceforge.net/projects/mcuoneclipse
**  * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx
**  * All rights reserved.
**  *
**  * Redistribution and use in source and binary forms, with or without modification,
**  * are permitted provided that the following conditions are met:
**  *
**  * - Redistributions of source code must retain the above copyright notice, this list
**  *   of conditions and the following disclaimer.
**  *
**  * - Redistributions in binary form must reproduce the above copyright notice, this
**  *   list of conditions and the following disclaimer in the documentation and/or
**  *   other materials provided with the distribution.
**  *
**  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE..com
** ###################################################################*/
/*!
** @file TSL1.h
** @version 01.00
** @brief
**
*/         
/*!
**  @addtogroup TSL1_module TSL1 module documentation
**  @{
*/         

/* MODULE TSL1. */

#include "TSL1.h"
#include "GI2C1.h"
#include "WAIT1.h"
#include "UTIL1.h"

#define TSL2561_COMMAND_BIT (0x80)    // Must be 1
#define TSL2561_CLEAR_BIT   (0x40)    // Clears any pending interrupt (write 1 to clear)
#define TSL2561_WORD_BIT    (0x20)    // read/write word (rather than byte)
#define TSL2561_BLOCK_BIT   (0x10)    // using block read/write

#define TSL2561_CONTROL_POWERON  (0x03)
#define TSL2561_CONTROL_POWEROFF (0x00)

#define TSL2561_LUX_SCALE     (14)      // Scale by 2^14
#define TSL2561_RATIO_SCALE   (9)       // Scale ratio by 2^9
#define TSL2561_CHSCALE       (10)      // Scale channel values by 2^10
#define TSL2561_CHSCALE_TINT0 (0x7517)  // 322/11 * 2^TSL2561_LUX_CHSCALE
#define TSL2561_CHSCALE_TINT1 (0x0FE7)  // 322/81 * 2^TSL2561_LUX_CHSCALE

// T, FN and CL package values
#define TSL2561_LUX_K1T           (0x0040)  // 0.125 * 2^RATIO_SCALE
#define TSL2561_LUX_B1T           (0x01f2)  // 0.0304 * 2^LUX_SCALE
#define TSL2561_LUX_M1T           (0x01be)  // 0.0272 * 2^LUX_SCALE
#define TSL2561_LUX_K2T           (0x0080)  // 0.250 * 2^RATIO_SCALE
#define TSL2561_LUX_B2T           (0x0214)  // 0.0325 * 2^LUX_SCALE
#define TSL2561_LUX_M2T           (0x02d1)  // 0.0440 * 2^LUX_SCALE
#define TSL2561_LUX_K3T           (0x00c0)  // 0.375 * 2^RATIO_SCALE
#define TSL2561_LUX_B3T           (0x023f)  // 0.0351 * 2^LUX_SCALE
#define TSL2561_LUX_M3T           (0x037b)  // 0.0544 * 2^LUX_SCALE
#define TSL2561_LUX_K4T           (0x0100)  // 0.50 * 2^RATIO_SCALE
#define TSL2561_LUX_B4T           (0x0270)  // 0.0381 * 2^LUX_SCALE
#define TSL2561_LUX_M4T           (0x03fe)  // 0.0624 * 2^LUX_SCALE
#define TSL2561_LUX_K5T           (0x0138)  // 0.61 * 2^RATIO_SCALE
#define TSL2561_LUX_B5T           (0x016f)  // 0.0224 * 2^LUX_SCALE
#define TSL2561_LUX_M5T           (0x01fc)  // 0.0310 * 2^LUX_SCALE
#define TSL2561_LUX_K6T           (0x019a)  // 0.80 * 2^RATIO_SCALE
#define TSL2561_LUX_B6T           (0x00d2)  // 0.0128 * 2^LUX_SCALE
#define TSL2561_LUX_M6T           (0x00fb)  // 0.0153 * 2^LUX_SCALE
#define TSL2561_LUX_K7T           (0x029a)  // 1.3 * 2^RATIO_SCALE
#define TSL2561_LUX_B7T           (0x0018)  // 0.00146 * 2^LUX_SCALE
#define TSL2561_LUX_M7T           (0x0012)  // 0.00112 * 2^LUX_SCALE
#define TSL2561_LUX_K8T           (0x029a)  // 1.3 * 2^RATIO_SCALE
#define TSL2561_LUX_B8T           (0x0000)  // 0.000 * 2^LUX_SCALE
#define TSL2561_LUX_M8T           (0x0000)  // 0.000 * 2^LUX_SCALE

// CS package values
#define TSL2561_LUX_K1C           (0x0043)  // 0.130 * 2^RATIO_SCALE
#define TSL2561_LUX_B1C           (0x0204)  // 0.0315 * 2^LUX_SCALE
#define TSL2561_LUX_M1C           (0x01ad)  // 0.0262 * 2^LUX_SCALE
#define TSL2561_LUX_K2C           (0x0085)  // 0.260 * 2^RATIO_SCALE
#define TSL2561_LUX_B2C           (0x0228)  // 0.0337 * 2^LUX_SCALE
#define TSL2561_LUX_M2C           (0x02c1)  // 0.0430 * 2^LUX_SCALE
#define TSL2561_LUX_K3C           (0x00c8)  // 0.390 * 2^RATIO_SCALE
#define TSL2561_LUX_B3C           (0x0253)  // 0.0363 * 2^LUX_SCALE
#define TSL2561_LUX_M3C           (0x0363)  // 0.0529 * 2^LUX_SCALE
#define TSL2561_LUX_K4C           (0x010a)  // 0.520 * 2^RATIO_SCALE
#define TSL2561_LUX_B4C           (0x0282)  // 0.0392 * 2^LUX_SCALE
#define TSL2561_LUX_M4C           (0x03df)  // 0.0605 * 2^LUX_SCALE
#define TSL2561_LUX_K5C           (0x014d)  // 0.65 * 2^RATIO_SCALE
#define TSL2561_LUX_B5C           (0x0177)  // 0.0229 * 2^LUX_SCALE
#define TSL2561_LUX_M5C           (0x01dd)  // 0.0291 * 2^LUX_SCALE
#define TSL2561_LUX_K6C           (0x019a)  // 0.80 * 2^RATIO_SCALE
#define TSL2561_LUX_B6C           (0x0101)  // 0.0157 * 2^LUX_SCALE
#define TSL2561_LUX_M6C           (0x0127)  // 0.0180 * 2^LUX_SCALE
#define TSL2561_LUX_K7C           (0x029a)  // 1.3 * 2^RATIO_SCALE
#define TSL2561_LUX_B7C           (0x0037)  // 0.00338 * 2^LUX_SCALE
#define TSL2561_LUX_M7C           (0x002b)  // 0.00260 * 2^LUX_SCALE
#define TSL2561_LUX_K8C           (0x029a)  // 1.3 * 2^RATIO_SCALE
#define TSL2561_LUX_B8C           (0x0000)  // 0.000 * 2^LUX_SCALE
#define TSL2561_LUX_M8C           (0x0000)  // 0.000 * 2^LUX_SCALE

#define TSL2561_REG_CONTROL          (0x00)
#define TSL2561_REG_TIMING           (0x01)
#define TSL2561_REG_THRESHHOLDL_LOW  (0x02)
#define TSL2561_REG_THRESHHOLDL_HIGH (0x03)
#define TSL2561_REG_THRESHHOLDH_LOW  (0x04)
#define TSL2561_REG_THRESHHOLDH_HIGH (0x05)
#define TSL2561_REG_INTERRUPT        (0x06)
#define TSL2561_REG_CRC              (0x08)
#define TSL2561_REG_ID               (0x0A)
#define TSL2561_REG_CHAN0_LOW        (0x0C)
#define TSL2561_REG_CHAN0_HIGH       (0x0D)
#define TSL2561_REG_CHAN1_LOW        (0x0E)
#define TSL2561_REG_CHAN1_HIGH       (0x0F)

// Auto-gain thresholds
#define TSL2561_AGC_THI_13MS      (4850)    // Max value at Ti 13ms = 5047
#define TSL2561_AGC_TLO_13MS      (100)
#define TSL2561_AGC_THI_101MS     (36000)   // Max value at Ti 101ms = 37177
#define TSL2561_AGC_TLO_101MS     (200)
#define TSL2561_AGC_THI_402MS     (63000)   // Max value at Ti 402ms = 65535
#define TSL2561_AGC_TLO_402MS     (500)

// Clipping thresholds
#define TSL2561_CLIPPING_13MS     (4900)
#define TSL2561_CLIPPING_101MS    (37000)
#define TSL2561_CLIPPING_402MS    (65000)

#define TSL2561_LUX_LUXSCALE      (14)      // Scale by 2^14
#define TSL2561_LUX_RATIOSCALE    (9)       // Scale ratio by 2^9
#define TSL2561_LUX_CHSCALE       (10)      // Scale channel values by 2^10
#define TSL2561_LUX_CHSCALE_TINT0 (0x7517)  // 322/11 * 2^TSL2561_LUX_CHSCALE
#define TSL2561_LUX_CHSCALE_TINT1 (0x0FE7)  // 322/81 * 2^TSL2561_LUX_CHSCALE

static uint8_t _tsl2561IntegrationTime = TSL2561_INTEGRATION_TIME_13MS;
static uint8_t _tsl2561Gain = TSL2561_GAIN_16X;

#if TSL1_CONFIG_PARSE_COMMAND_ENABLED
static uint8_t PrintStatus(const CLS1_StdIOType *io) {
  uint8_t buf[32], ambient;
  uint16_t broadband, ir;
  uint32_t lux;

  CLS1_SendStatusStr((unsigned char*)"TSL1", (unsigned char*)"\r\n", io->stdOut);

  if (_tsl2561Gain==TSL2561_GAIN_1X) {
    UTIL1_Num8uToStr(buf, sizeof(buf), _tsl2561Gain+1); /* 1x is zero value */
  } else {
    UTIL1_Num8uToStr(buf, sizeof(buf), _tsl2561Gain);
  }
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  gain", buf, io->stdOut);

  if (_tsl2561IntegrationTime==TSL2561_INTEGRATION_TIME_13MS) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"0: 13.7 ms\r\n");
  } else if (_tsl2561IntegrationTime==TSL2561_INTEGRATION_TIME_101MS) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"1: 101 ms\r\n");
  } else if (_tsl2561IntegrationTime==TSL2561_INTEGRATION_TIME_402MS) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"2: 402 ms\r\n");
  } else {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"WRONG VALUE?\r\n");
  }
  CLS1_SendStatusStr((unsigned char*)"  integration", buf, io->stdOut);

  if (TSL1_ReadRawDataFull(&broadband)==ERR_OK) {
    UTIL1_Num16uToStr(buf, sizeof(buf), broadband);
    UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  } else {
    broadband = 0;
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"ERROR\r\n");
  }
  CLS1_SendStatusStr((unsigned char*)"  broadband", buf, io->stdOut);
  if (TSL1_ReadRawDataInfrared(&ir)==ERR_OK) {
    UTIL1_Num16uToStr(buf, sizeof(buf), ir);
    UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"%\r\n");
  } else {
    ir = 0;
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"ERROR\r\n");
  }
  CLS1_SendStatusStr((unsigned char*)"  infrared", buf, io->stdOut);

  lux = TSL1_CalculateLux(broadband, ir);
  if (lux!=TSL2561_LUX_SATURATED_VALUE) {
    UTIL1_Num32uToStr(buf, sizeof(buf), lux);
  } else {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"saturated");
  }
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  lux", buf, io->stdOut);

  TSL1_LuxToAmbientPercentage(lux, &ambient);
  UTIL1_Num8uToStr(buf, sizeof(buf), ambient);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  ambient", buf, io->stdOut);

  TSL1_GetLuminosity(&broadband, &ir);
  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"broad: ");
  UTIL1_strcatNum16u(buf, sizeof(buf), broadband);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" IR: ");
  UTIL1_strcatNum16u(buf, sizeof(buf), ir);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  luminosity", buf, io->stdOut);

  return ERR_OK;
}

static uint8_t PrintHelp(const CLS1_StdIOType *io) {
  CLS1_SendHelpStr((unsigned char*)"TSL1", (unsigned char*)"Group of TSL1 commands\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  gain (1|16)", (unsigned char*)"Set gain value\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  integration (13|101|402)", (unsigned char*)"Set intergration time (ms)\r\n", io->stdOut);
  return ERR_OK;
}
#endif /* TSL1_CONFIG_PARSE_COMMAND_ENABLED */
/*
** ===================================================================
**     Method      :  Deinit (component TSL2561)
**
**     Description :
**         Driver de-initialization
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void TSL1_Deinit(void)
{
  /* nothing needed */
}

/*
** ===================================================================
**     Method      :  Init (component TSL2561)
**
**     Description :
**         Driver Initialization
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void TSL1_Init(void)
{
  /* initialize sensor from the application */
}

/*
** ===================================================================
**     Method      :  Disable (component TSL2561)
**
**     Description :
**         Disables the device
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t TSL1_Disable(void)
{
  return GI2C1_WriteByteAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_CONTROL, TSL2561_CONTROL_POWEROFF);
}

/*
** ===================================================================
**     Method      :  Enable (component TSL2561)
**
**     Description :
**         Enables the device
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t TSL1_Enable(void)
{
  return GI2C1_WriteByteAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_CONTROL, TSL2561_CONTROL_POWERON);
}

/*
** ===================================================================
**     Method      :  ParseCommand (component TSL2561)
**
**     Description :
**         Shell Command Line parser. Method is only available if Shell
**         is enabled in the component properties.
**     Parameters  :
**         NAME            - DESCRIPTION
**         cmd             - command string
**       * handled         - Pointer to variable which tells if
**                           the command has been handled or not
**         io              - Pointer to I/O structure
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t TSL1_ParseCommand(const unsigned char* cmd, bool *handled, const CLS1_StdIOType *io)
{
#if TSL1_CONFIG_PARSE_COMMAND_ENABLED
  uint8_t res = ERR_OK;

  if (UTIL1_strcmp((char*)cmd, CLS1_CMD_HELP) == 0
    || UTIL1_strcmp((char*)cmd, "TSL1 help") == 0)
  {
    *handled = TRUE;
    return PrintHelp(io);
  } else if (   (UTIL1_strcmp((char*)cmd, CLS1_CMD_STATUS)==0)
             || (UTIL1_strcmp((char*)cmd, "TSL1 status")==0)
            )
  {
    *handled = TRUE;
    res = PrintStatus(io);
  } else if (UTIL1_strcmp((char*)cmd, "TSL1 gain 1")==0) {
    *handled = TRUE;
    res = TSL1_SetGain(TSL2561_GAIN_1X);
  } else if (UTIL1_strcmp((char*)cmd, "TSL1 gain 16")==0) {
    *handled = TRUE;
    res = TSL1_SetGain(TSL2561_GAIN_16X);
  } else if (UTIL1_strcmp((char*)cmd, "TSL1 integration 13")==0) {
    *handled = TRUE;
    res = TSL1_SetIntegrationTime(TSL2561_INTEGRATION_TIME_13MS);
  } else if (UTIL1_strcmp((char*)cmd, "TSL1 integration 101")==0) {
    *handled = TRUE;
    res = TSL1_SetIntegrationTime(TSL2561_INTEGRATION_TIME_101MS);
  } else if (UTIL1_strcmp((char*)cmd, "TSL1 integration 402")==0) {
    *handled = TRUE;
    res = TSL1_SetIntegrationTime(TSL2561_INTEGRATION_TIME_402MS);
  }
  return res;
#else
  (void)cmd;
  (void)handled;
  (void)io;
  return ERR_OK;
#endif
}

/*
** ===================================================================
**     Method      :  SetIntegrationTime (component TSL2561)
**
**     Description :
**         Sets the sensor integration time
**     Parameters  :
**         NAME            - DESCRIPTION
**         timing          - integration timing
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t TSL1_SetIntegrationTime(uint8_t timing)
{
  _tsl2561IntegrationTime = timing;
  return GI2C1_WriteByteAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_TIMING, timing|_tsl2561Gain);
}

/*
** ===================================================================
**     Method      :  SetGain (component TSL2561)
**
**     Description :
**         Sets the sensor gain
**     Parameters  :
**         NAME            - DESCRIPTION
**         gain            - gain value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t TSL1_SetGain(uint8_t gain)
{
  _tsl2561Gain = gain;
  return GI2C1_WriteByteAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_TIMING, gain|_tsl2561IntegrationTime);
}

/*
** ===================================================================
**     Method      :  ReadRawDataFull (component TSL2561)
**
**     Description :
**         Read the raw full/broadband light data value
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to where to store the data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t TSL1_ReadRawDataFull(uint16_t *data)
{
  /* read IR and visible light channel */
  uint8_t res;

  *data = 0;
  res = GI2C1_ReadWordAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_CHAN0_LOW, data);
  if (res!=ERR_OK) {
    return res;
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  ReadRawDataInfrared (component TSL2561)
**
**     Description :
**         Read the raw infrared light data value
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to where to store the data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t TSL1_ReadRawDataInfrared(uint16_t *data)
{
  uint8_t res;

  *data = 0;
  res = GI2C1_ReadWordAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_CHAN1_LOW, data);
  if (res!=ERR_OK) {
    return res;
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  ReadData (component TSL2561)
**
**     Description :
**         Read the broadband/full and infrared data
**     Parameters  :
**         NAME            - DESCRIPTION
**       * broadband       - Pointer to where to store the
**                           data
**       * ir              - Pointer to store the infrared value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t TSL1_ReadData(uint16_t *broadband, uint16_t *ir)
{
  uint8_t res;

  *broadband = 0;
  *ir = 0;
  res = TSL1_ReadRawDataFull(broadband);
  if (res!=ERR_OK) {
    return res;
  }
  res = TSL1_ReadRawDataInfrared(ir);
  if (res!=ERR_OK) {
    return res;
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  CalculateLux (component TSL2561)
**
**     Description :
**         Calculates the LUX value based on broadband and infrared
**         values
**     Parameters  :
**         NAME            - DESCRIPTION
**         broadband       - full/broadband light value
**         ir              - Infrared value
**     Returns     :
**         ---             - LUX value
** ===================================================================
*/
uint32_t TSL1_CalculateLux(uint16_t broadband, uint16_t ir)
{
  unsigned long chScale;
  unsigned long channel1;
  unsigned long channel0;

  /* Make sure the sensor isn't saturated! */
  uint16_t clipThreshold;

  switch (_tsl2561IntegrationTime) {
    case TSL2561_INTEGRATION_TIME_13MS:
      clipThreshold = TSL2561_CLIPPING_13MS;
      break;
    case TSL2561_INTEGRATION_TIME_101MS:
      clipThreshold = TSL2561_CLIPPING_101MS;
      break;
    default:
      clipThreshold = TSL2561_CLIPPING_402MS;
      break;
  }

  /* Return 65536 lux if the sensor is saturated */
  if ((broadband > clipThreshold) || (ir > clipThreshold)) {
    return TSL2561_LUX_SATURATED_VALUE;
  }

  /* Get the correct scale depending on the integration time */
  switch (_tsl2561IntegrationTime) {
    case TSL2561_INTEGRATION_TIME_13MS:
      chScale = TSL2561_LUX_CHSCALE_TINT0;
      break;
    case TSL2561_INTEGRATION_TIME_101MS:
      chScale = TSL2561_LUX_CHSCALE_TINT1;
      break;
    default: /* No scaling ... integration time = 402ms */
      chScale = (1 << TSL2561_LUX_CHSCALE);
      break;
  }

  /* Scale for gain (1x or 16x) */
  if (!_tsl2561Gain) {
    chScale = chScale << 4;
  }

  /* Scale the channel values */
  channel0 = (broadband * chScale) >> TSL2561_LUX_CHSCALE;
  channel1 = (ir * chScale) >> TSL2561_LUX_CHSCALE;

  /* Find the ratio of the channel values (Channel1/Channel0) */
  unsigned long ratio1 = 0;
  if (channel0 != 0) ratio1 = (channel1 << (TSL2561_LUX_RATIOSCALE+1)) / channel0;

  /* round the ratio value */
  unsigned long ratio = (ratio1 + 1) >> 1;

  unsigned int b, m;

#if TSL2561_CONFIG_PACKAGE_CS
  if ((ratio >= 0) && (ratio <= TSL2561_LUX_K1C))
    {b=TSL2561_LUX_B1C; m=TSL2561_LUX_M1C;}
  else if (ratio <= TSL2561_LUX_K2C)
    {b=TSL2561_LUX_B2C; m=TSL2561_LUX_M2C;}
  else if (ratio <= TSL2561_LUX_K3C)
    {b=TSL2561_LUX_B3C; m=TSL2561_LUX_M3C;}
  else if (ratio <= TSL2561_LUX_K4C)
    {b=TSL2561_LUX_B4C; m=TSL2561_LUX_M4C;}
  else if (ratio <= TSL2561_LUX_K5C)
    {b=TSL2561_LUX_B5C; m=TSL2561_LUX_M5C;}
  else if (ratio <= TSL2561_LUX_K6C)
    {b=TSL2561_LUX_B6C; m=TSL2561_LUX_M6C;}
  else if (ratio <= TSL2561_LUX_K7C)
    {b=TSL2561_LUX_B7C; m=TSL2561_LUX_M7C;}
  else if (ratio > TSL2561_LUX_K8C)
    {b=TSL2561_LUX_B8C; m=TSL2561_LUX_M8C;}
#else
  if ((ratio >= 0) && (ratio <= TSL2561_LUX_K1T))
    {b=TSL2561_LUX_B1T; m=TSL2561_LUX_M1T;}
  else if (ratio <= TSL2561_LUX_K2T)
    {b=TSL2561_LUX_B2T; m=TSL2561_LUX_M2T;}
  else if (ratio <= TSL2561_LUX_K3T)
    {b=TSL2561_LUX_B3T; m=TSL2561_LUX_M3T;}
  else if (ratio <= TSL2561_LUX_K4T)
    {b=TSL2561_LUX_B4T; m=TSL2561_LUX_M4T;}
  else if (ratio <= TSL2561_LUX_K5T)
    {b=TSL2561_LUX_B5T; m=TSL2561_LUX_M5T;}
  else if (ratio <= TSL2561_LUX_K6T)
    {b=TSL2561_LUX_B6T; m=TSL2561_LUX_M6T;}
  else if (ratio <= TSL2561_LUX_K7T)
    {b=TSL2561_LUX_B7T; m=TSL2561_LUX_M7T;}
  else if (ratio > TSL2561_LUX_K8T)
    {b=TSL2561_LUX_B8T; m=TSL2561_LUX_M8T;}
#endif

  unsigned long temp;
  temp = ((channel0 * b) - (channel1 * m));

  /* Do not allow negative lux value */
  if (temp < 0) {
    temp = 0;
  }

  /* Round lsb (2^(LUX_SCALE-1)) */
  temp += (1 << (TSL2561_LUX_LUXSCALE-1));

  /* Strip off fractional portion */
  uint32_t lux = temp >> TSL2561_LUX_LUXSCALE;

  return lux;
}

/*
** ===================================================================
**     Method      :  GetLuminosity (component TSL2561)
**
**     Description :
**         Gets the broadband (mixed lighting) and IR only values from
**         the TSL2561, adjusting gain if auto-gain is enabled
**     Parameters  :
**         NAME            - DESCRIPTION
**       * broadband       - Pointer to where to store the
**                           broadband value
**       * ir              - Pointer to store the infrared value
**     Returns     : Nothing
** ===================================================================
*/
void TSL1_GetLuminosity(uint16_t *broadband, uint16_t *ir)
{
  bool valid = FALSE;

  /* Read data until we find a valid range */
  bool _agcCheck = FALSE;
  do {
    uint16_t _b, _ir;
    uint16_t _hi, _lo;
    uint8_t _it = _tsl2561IntegrationTime;

    /* Get the hi/low threshold for the current integration time */
    switch(_it) {
      case TSL2561_INTEGRATION_TIME_13MS:
        _hi = TSL2561_AGC_THI_13MS;
        _lo = TSL2561_AGC_TLO_13MS;
        break;
      case TSL2561_INTEGRATION_TIME_101MS:
        _hi = TSL2561_AGC_THI_101MS;
        _lo = TSL2561_AGC_TLO_101MS;
        break;
      default:
        _hi = TSL2561_AGC_THI_402MS;
        _lo = TSL2561_AGC_TLO_402MS;
        break;
    }
    (void)TSL1_ReadData(&_b, &_ir);
    /* Run an auto-gain check if we haven't already done so ... */
    if (!_agcCheck){
      if ((_b < _lo) && (_tsl2561Gain == TSL2561_GAIN_1X)) {
        /* Increase the gain and try again */
        TSL1_SetGain(TSL2561_GAIN_16X);
        /* Drop the previous conversion results */
        (void)TSL1_ReadData(&_b, &_ir);
        /* Set a flag to indicate we've adjusted the gain */
        _agcCheck = TRUE;
      } else if ((_b > _hi) && (_tsl2561Gain == TSL2561_GAIN_16X)) {
        /* Drop gain to 1x and try again */
        TSL1_SetGain(TSL2561_GAIN_1X);
        /* Drop the previous conversion results */
        (void)TSL1_ReadData(&_b, &_ir);
        /* Set a flag to indicate we've adjusted the gain */
        _agcCheck = TRUE;
      } else {
        /* Nothing to look at here, keep moving ....
           Reading is either valid, or we're already at the chips limits */
        *broadband = _b;
        *ir = _ir;
        valid = TRUE;
      }
    } else {
      /* If we've already adjusted the gain once, just return the new results.
         This avoids endless loops where a value is at one extreme pre-gain,
         and the the other extreme post-gain */
      *broadband = _b;
      *ir = _ir;
      valid = TRUE;
    }
  } while (!valid);
}

/*
** ===================================================================
**     Method      :  GetLux (component TSL2561)
**
**     Description :
**         Returns the sensor value in LUX
**     Parameters  :
**         NAME            - DESCRIPTION
**       * lux             - Pointer to where to store the Lux value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t TSL1_GetLux(uint32_t *lux)
{
  uint8_t res;
  uint16_t broadband, infrared;

  *lux = 0; /* init */
  res = TSL1_ReadRawDataFull(&broadband);
  if (res!=ERR_OK) {
    return res;
  }
  res = TSL1_ReadRawDataInfrared(&infrared);
  if (res!=ERR_OK) {
    return res;
  }
  *lux = TSL1_CalculateLux(broadband, infrared);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  LuxToAmbientPercentage (component TSL2561)
**
**     Description :
**         Transformes the Lux value into an ambient percentage value
**         (0-100%)
**     Parameters  :
**         NAME            - DESCRIPTION
**         luxVal          - Lux input value
**       * ambient         - Pointer to where to store the
**                           ambient percentage value
**     Returns     : Nothing
** ===================================================================
*/
void TSL1_LuxToAmbientPercentage(uint32_t luxVal, uint8_t *ambient)
{
  if (luxVal<128) {
    *ambient = (luxVal*100)>>7;
  } else {
    *ambient = 100;
  }
}

/* END TSL1. */

/*!
** @}
*/
