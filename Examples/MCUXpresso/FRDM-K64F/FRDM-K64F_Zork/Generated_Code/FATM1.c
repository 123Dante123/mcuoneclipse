/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : FATM1.h
**     Project     : FRDM-K64F_Zork
**     Processor   : MK64FN1M0VLQ12
**     Component   : FatFsMemSDHC
**     Version     : Component 01.044, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2018-12-02, 21:22, # CodeGen: 12
**     Abstract    :
**
**     Settings    :
**
**     Contents    :
**         CardPresent      - bool FATM1_CardPresent(void);
**         isWriteProtected - bool FATM1_isWriteProtected(void);
**         Activate         - void FATM1_Activate(void);
**         Deactivate       - void FATM1_Deactivate(void);
**         Deinit           - uint8_t FATM1_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         Init             - uint8_t FATM1_Init(LDD_TUserData *UserDataPtr);
**
** License   :  Open Source (LGPL)
** Copyright : (c) Copyright Erich Styger, 2013-2018, all rights reserved.
** Web       : www.mcuoneclipse.com
** 
** This an open source software using Processor Expert.
** This is a free software and is opened for education,  research and commercial developments under license policy of following terms:
** * This is a free software and there is NO WARRANTY.
** * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
** * Redistributions of source code must retain the above copyright notice.
** ###################################################################*/
/*!
** @file FATM1.h
** @version 01.00
** @brief
**
*/         
/*!
**  @addtogroup FATM1_module FATM1 module documentation
**  @{
*/         

/* MODULE FATM1. */

#include "Events.h"
#include "FATM1.h"
#include "ff.h"
#include "diskio.h"


static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
static TSDData SD;              /* Application data */

#define FATM1_SPEED_INDEX_SLOW    0    /* set by property, has to correspond to less than 400 kHz. */
#define FATM1_SPEED_INDEX_NORMAL  1    /* set by property, up to 12 MHz. */
#define FATM1_SPEED_INDEX_FAST    2    /* set by property, depends on card, but could be as high as 48 MHz. */

/* Internal method prototypes */
static void SD_Wait(TSDData *SD, bool *ErrorFlag);

/*
** ===================================================================
**     Method      :  FATM1_OnCardInserted (component FatFsMemSDHC)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void SDHC1_OnCardInserted(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->CardId = Id;
}

/*
** ===================================================================
**     Method      :  FATM1_OnCardRemoved (component FatFsMemSDHC)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void SDHC1_OnCardRemoved(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->CardId = SDHC1_NO_CARD;
  (void)Id; /* unused */
}

/*
** ===================================================================
**     Method      :  FATM1_OnFinished (component FatFsMemSDHC)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void SDHC1_OnFinished(LDD_TUserData *UserDataPtr)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->Finished = TRUE;
}

/*
** ===================================================================
**     Method      :  CardPresent (component FatFsMemSDHC)
**
**     Description :
**         Returns TRUE if card is present
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
bool FATM1_CardPresent(void)
{
  return CD1_GetVal()!=0;
}

/*
** ===================================================================
**     Method      :  SD_Wait (component FatFsMemSDHC)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void SD_Wait(TSDData *SD, bool *ErrorFlag)
{
  TMOUT1_CounterHandle timeout;
  bool isTimeout;      /* Timeout flag */
  LDD_SDHC_TError err;     /* SDHC error */

  if (!SD->Finished) { /* not finished yet? */
    isTimeout = FALSE;
    timeout = TMOUT1_GetCounter(FATM1_WAIT_TIMEOUT_MS/TMOUT1_TICK_PERIOD_MS); /* set up timeout counter */
    while (!SD->Finished && !isTimeout) {
      WAIT1_WaitOSms(1);
      isTimeout = TMOUT1_CounterExpired(timeout);
    }
    TMOUT1_LeaveCounter(timeout);
    if (isTimeout) {
      FATM1_OnError(0); /* call user error handler */
      *ErrorFlag = TRUE;
    }
  }
  SD->Finished = FALSE; /* reset flag */
  err = SDHC1_GetError(SD->SDHCPtr, NULL);
  if (err != LDD_SDHC_ERR_OK) {
    FATM1_OnError(err); /* call user error handler */
    *ErrorFlag = TRUE;
  }
}

/*
** ===================================================================
**     Method      :  Init (component FatFsMemSDHC)
**
**     Description :
**         Initialization method
**     Parameters  :
**         NAME            - DESCRIPTION
**       * UserDataPtr     - Pointer to RTOS structure
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
#include "PORT_PDD.h"  /* user provided include code */
uint8_t FATM1_Init(LDD_TUserData *UserDataPtr)
{
  bool Error = FALSE;

  (void)UserDataPtr; /* not used */
  /* Enable pull-up/pull-down on GPIO pin used for SD card detection with user code provided in properties */
  PORT_PDD_SetPinPullSelect(PORTE_BASE_PTR, 6, PORT_PDD_PULL_DOWN);  PORT_PDD_SetPinPullEnable(PORTE_BASE_PTR, 6, PORT_PDD_PULL_ENABLE);  /* user provided code */
#if FATM1_CONFIG_DISABLE_MPU
  MPU_CESR = 0; /* K64F has memory protection unit, disable it! */
#endif
  /* initialize device structure */
  SD.SDHCPtr = 0;
  SD.Finished = FALSE;
  SD.CardId = SDHC1_NO_CARD;
  SD.SDHCPtr = SDHC1_Init(&SD);
  SD.Inserted = FATM1_CardPresent();
  SD_Wait(&SD, &Error); /* Wait for card reset to finish */
  if (!Error) {
    return ERR_OK;
  } else {
    return ERR_FAILED;
  }
}

/*
** ===================================================================
**     Method      :  Deinit (component FatFsMemSDHC)
**
**     Description :
**         Method to deinitialize the device driver
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Pointer to RTOS
**                           structure
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t FATM1_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  (void)DeviceDataPtr; /* not used */
  /* Deinit components/devices */
  SDHC1_Deinit(SD.SDHCPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  Activate (component FatFsMemSDHC)
**
**     Description :
**         Activates the communication channel
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FATM1_Activate(void)
{
  /* nothing needed right now */
}

/*
** ===================================================================
**     Method      :  Deactivate (component FatFsMemSDHC)
**
**     Description :
**         Deactivates the communication channel
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FATM1_Deactivate(void)
{
  /* nothing needed right now */
}

/*
** ===================================================================
**     Method      :  isWriteProtected (component FatFsMemSDHC)
**
**     Description :
**         Returns TRUE if card is write protected
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
bool FATM1_isWriteProtected(void)
{
  return FALSE; /* 'FALSE' provided as isWriteProtected() function in properties */
}

static uint32_t SD_ByteToCardAddress(LDD_SDHC_TCardInfo *CardInfo, uint32_t Address) {
  const uint32_t BlockSizeExp = 9;

  return (CardInfo->Caps.HighCapacity ? Address >> BlockSizeExp : Address);
}

static bool SD_TransferBlock(TSDData *SD, bool Read, uint32_t Address, uint8_t *Buffer) {
  bool Error = FALSE;
  const uint16_t BlockSize = FATM1_BLOCK_SIZE;
  const uint16_t BlockCount = 1;
  uint32_t CardAddr = SD_ByteToCardAddress(&SD->CardInfo, Address); /* Read block address */
  LDD_SDHC_TBufferDesc BufferDesc;

  /* Init read buffer descriptor */
  BufferDesc.DataPtr = Buffer;
  BufferDesc.Size = BlockSize;
  /* Read card data block */
  if (SDHC1_TransferBlocks(SD->SDHCPtr, (Read ? LDD_SDHC_READ : LDD_SDHC_WRITE), CardAddr, &BufferDesc, BlockCount)!=ERR_OK) {
    FATM1_OnError(0); /* call user error handler */
    return TRUE; /* error */
  }
  SD_Wait(SD, &Error);
  return Error;
}
/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
DSTATUS FATM1_disk_initialize (
        uint8_t drv                     /* Physical drive number (0..) */
)
{
  bool Error = FALSE;

  (void)drv; /* not used */
  if (Stat & STA_NODISK) {
    return Stat;                        /* No card in the socket */
  }
  if (SD.SDHCPtr!=NULL) { /* deallocate any existing driver structures first */
    SDHC1_Deinit(SD.SDHCPtr);
    SD.SDHCPtr = NULL;
  }
  if (FATM1_Init(NULL)!=ERR_OK) {
    return STA_NOINIT;
  }
  if (!Error && SD.Inserted) {
    if (SDHC1_DetectCards(SD.SDHCPtr)!=ERR_OK) {
      Error = TRUE;
    }
    SD_Wait(&SD, &Error);
    if (!Error && SD.CardId != SDHC1_NO_CARD) {
      /* card detected - selecting card... */
      if (SDHC1_SelectCard(SD.SDHCPtr, SD.CardId)!=ERR_OK) {
        Error = TRUE;
      }
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      /* card selected - requesting card info... */
      if (SDHC1_GetCardInfo(SD.SDHCPtr, &SD.CardInfo)!=ERR_OK) {
        Error = TRUE;
      }
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      /* switching gears for higher speed */
      Error = SDHC1_SelectBusClock(SD.SDHCPtr, (SDHC1_TBusClock)FATM1_SPEED_INDEX_NORMAL)!=ERR_OK;
      WAIT1_WaitOSms(10); /* switching the bus clock needs some time? */
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_8_BIT) {
        Error = SDHC1_SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_8_BIT)!=ERR_OK;
      } else if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_4_BIT) {
        Error = SDHC1_SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_4_BIT)!=ERR_OK;
      } else if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_1_BIT) {
        Error = SDHC1_SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_1_BIT)!=ERR_OK;
      }
      SD_Wait(&SD, &Error);
    }
    if (!Error && SD.CardInfo.Caps.HighSpeed) {
      Error = SDHC1_SelectBusClock(SD.SDHCPtr, (SDHC1_TBusClock)FATM1_SPEED_INDEX_FAST)!=ERR_OK;
      WAIT1_WaitOSms(10); /* switching the bus clock needs some time? */
      SD_Wait(&SD, &Error);
      /* running at high speed (high slew rate on all the SDHC pins should be set) */
    }
  }
  if (!Error) { /* clear flag if there were no errors */
    Stat &= ~STA_NOINIT;                /* Clear STA_NOINIT */
  }
  return Stat;
}
/*-----------------------------------------------------------------------*/
/* Return Disk Status                                                    */
DSTATUS FATM1_disk_status (
        uint8_t drv                     /* Physical drive number (0..) */
)
{
  (void)drv; /* not used */
  return Stat;
}
/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
DRESULT FATM1_disk_read (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t *buff,                  /* Data buffer to store read data */
        uint32_t sector,                /* Sector address (LBA) */
        uint8_t count                   /* Number of sectors to read (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (count == 1) {                     /* Single block read */
    if (SD_TransferBlock(&SD, TRUE, sector*FATM1_BLOCK_SIZE, buff)) {
      return RES_ERROR;
    }
    count = 0;
  } else { /* read multiple blocks */
    do {
      if (SD_TransferBlock(&SD, TRUE, sector*FATM1_BLOCK_SIZE, buff)) {
        break;
      }
      sector++;
      buff += FATM1_BLOCK_SIZE;
    } while(--count);
  }
  return count ? RES_ERROR : RES_OK;
}
/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT FATM1_disk_write (
        uint8_t drv,                    /* Physical drive number (0..) */
        const uint8_t *buff,            /* Data to be written */
        uint32_t sector,                /* Sector address (LBA) */
        uint8_t count                   /* Number of sectors to write (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (Stat & STA_PROTECT) {
    return RES_WRPRT;
  }
  if (count==1) {                       /* Single block read */
    if (SD_TransferBlock(&SD, FALSE, sector*FATM1_BLOCK_SIZE, (uint8_t*)buff)) {
      return RES_ERROR;
    }
    count = 0;
  } else { /* read multiple blocks */
    do {
      if (SD_TransferBlock(&SD, FALSE, sector*FATM1_BLOCK_SIZE, (uint8_t*)buff)) {
        break;
      }
      sector++;
      buff += FATM1_BLOCK_SIZE;
    } while(--count);
  }
  return count ? RES_ERROR : RES_OK;
}
#endif /* _READONLY */
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
static bool chk_power(void) { return 1;}
static void power_off(void) {}
static void power_on(void) {}
/*-----------------------------------------------------------------------*/
DRESULT FATM1_disk_ioctl (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t ctrl,                   /* Control code */
        void *buff                      /* Buffer to send/receive control data */
)
{
  DRESULT res = RES_OK;
  uint8_t *ptr = (uint8_t*)buff;

  (void)drv; /* not used */
  if (ctrl == CTRL_POWER) {
    switch (*ptr) {
      case 0:                           /* Sub control code == 0 (POWER_OFF) */
        if (chk_power()) {
          power_off();                  /* Power off */
        }
        break;
      case 1:                           /* Sub control code == 1 (POWER_ON) */
        power_on();                     /* Power on */
        break;
      case 2:                           /* Sub control code == 2 (POWER_GET) */
        *(ptr+1) = (uint8_t)chk_power();
        break;
      default:
        res = RES_PARERR;
    } /* switch */
  } else {
    if (Stat & STA_NOINIT) {
      return RES_NOTRDY;
    }
    switch (ctrl) {
      case CTRL_SYNC :                  /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
        FATM1_Activate();
        break;
      case MMC_GET_READ_BL_LEN:         /* Block Length */
        *(uint16_t*)ptr = SD.CardInfo.BlockLength;
        break;
      case MMC_GET_SDC_VERSION:         /* get CSD Version (1 byte: 1 for 1.xx or MMC, 2 for 2.0 */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;
      case GET_SECTOR_COUNT:            /* Get number of sectors on the disk (uint32_t) */
        *(uint32_t*)buff = SD.CardInfo.BlockCount;
        break;
      case GET_SECTOR_SIZE:             /* Get R/W sector size (uint16_t) */
        *(uint16_t*)buff = FATM1_BLOCK_SIZE;
        break;
      case GET_BLOCK_SIZE:              /* Get erase block size in unit of sector (uint32_t) */
        *(uint32_t*)buff = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;
      case MMC_GET_TYPE:                /* Get card type flags (1 byte) */
        if (SD.CardInfo.Type==LDD_SDHC_SD) {
          *ptr = CT_SD1;
        } else if (SD.CardInfo.Type==LDD_SDHC_SDIO) {
          *ptr = CT_SD2;
        } else if (SD.CardInfo.Type==LDD_SDHC_MMC) {
          *ptr = CT_MMC;
        } else if (SD.CardInfo.Type==LDD_SDHC_SDCOMBO) {
          *ptr = CT_SDC;
        } else if (SD.CardInfo.Type==LDD_SDHC_CE_ATA) {
          *ptr = CT_ATA;
        } else {
          *ptr = 0; /* unknown ? */
          res = RES_PARERR;
        }
        break;

      case MMC_GET_CSD:                 /* Receive CSD as a data block (16 bytes) */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;

      case MMC_GET_CID:                 /* Receive CID as a data block (16 bytes) */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;

      case MMC_GET_OCR:                 /* Receive OCR as an R3 resp (4 bytes) */
       *ptr = 0;
       res = RES_PARERR; /* NYI or does not exist */
       break;

      case MMC_GET_SDSTAT:              /* Receive SD status as a data block (64 bytes) */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;

      case MMC_GET_DRIVER_VERSION:      /* 1 byte: return: 0 SPI driver, 1 LLD SDHC driver */
        *ptr = 1;
        break;

      case MMC_GET_LLD_INFO:
        /* ptr[0] is the command, ptr[1] is the size of data buffer, followed by the data buffer */
        switch(ptr[0]) {
          case MMC_GET_LLD_CMD_HIGH_CAPACITY:
            ptr[2] = SD.CardInfo.Caps.HighCapacity ? 1 : 0;
            break;
          case MMC_GET_LLD_CMD_HIGH_SPEED:
            ptr[2] = SD.CardInfo.Caps.HighSpeed ? 1 : 0;
            break;
          case MMC_GET_LLD_CMD_LOW_VOLTAGE:
            ptr[2] = SD.CardInfo.Caps.LowVoltage ? 1 : 0;
            break;
          case MMC_GET_LLD_CMD_DATA_WIDTHS:
            ptr[2] = SD.CardInfo.Caps.DataWidths;
            break;
          case MMC_GET_LLD_CMD_OPERATIONS:
            ptr[2] = SD.CardInfo.Caps.Operations;
            break;
          default:
            res = RES_PARERR;
            break;
        }
        break;

      default:
        res = RES_PARERR;
    } /* switch */
    FATM1_Deactivate();
  }
  return res;
}
/* END FATM1. */
